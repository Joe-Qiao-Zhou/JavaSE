# 面向对象

## 存储机制

- **一个.java文件中只能有一个public class**

- 分为5个部分
  - 栈内存：**方法在栈中运行**，只存储基本数据类型和对象引用
  - 堆内存：存储new出来的对象，数据均有默认值
  - 方法区：存储.class信息，包含**方法**信息
  - 本地方法栈：与OS相关
  - 寄存器：与CPU相关

![image-20211208104752769](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211208104752769.png)

![image-20211208142237996](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211208142237996.png)



## 成员变量和局部变量

- 定义位置不一样；作用范围不一样；**成员变量有默认值**，而局部变量没有；内存位置不一样；生命周期不一样：方法进出栈，对象创建与垃圾回收；
- private属性可以被public方法调用；private方法可以被public方法在类内部调用



## 标准类/Java Bean

- 所有成员变量均用private修饰
- 为每个成员变量创建一对set/get方法
- 具有无参构造方法
- 实现序列化接口



## 继承

- 单继承+多级继承
- 如果方法重名，看new的是谁就优先用谁的方法
- 如果直接访问成员变量则看左边；如果通过成员方法访问则看属于谁；如果重写了就看new的谁
- 子类构造方法默认隐含super()方法，先父类后子类；但是默认是无参的，有参需要重载；super()必须是**第一句**
- this()可以用在构造方法调用其他构造方法中，但是必须是第一句，且不能和super()**一起用**

![image-20211210110004661](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211210110004661.png)



## **重写**

- 子类对父类的更改，必须保持**完全一致**，用`@Override`注解来标识
- 子类访问权限**不能低于**父类：public>protected>(default)>private
- 返回值必须**小于等于**父类：Object>String



## 抽象类

- 抽象方法定义：`abstract关键字+无{}`
- 含有抽象方法的类**必须**声明为抽象类，类前也要加上abstract，**可以定义普通方法**
- 抽象类**不能**直接创建对象；必须有子类继承；子类必须重写所有抽象方法，如果没有全部重写则必须声明为抽象类
- 与接口的差别：
  - 子类只能继承**一个抽象类**，但能实现**多个接口**
  - 接口中全是抽象方法，没有构造方法，没有普通成员变量/可以有静态成员变量，没有静态方法



## 接口

- 只定义方法而不实现
- java7可包含常量和抽象方法，8可包含**默认方法**、静态方法，9可以包含私有方法
- 抽象方法的关键字必须是**pubic abstract**，两者都可以省略
- 通过实现类使用，重写所有抽象方法
- 实现类可以**实现多个接口**；如果接口抽象方法名称重复，实现一个就行；如果接口默认方法名称重复，要重写
- 接口不能有**静态**代码块和**构造**方法
- 默认方法：public default，**含有方法体**；
  - 原因：接口升级后多了一个抽象方法，而投入使用的实现类无法跟着重写新方法就会导致错误，因此需要加入方法体

- **静态方法**：直接通过接口来调用
- 私有方法：**默认方法**之间**重复**的内容抽取出来给其调用，而默认方法是public的导致实现类也可以调用，所以要定义为private
  - 普通私有方法：解决默认方法之间重复代码：`private 返回值类型 方法名称(参数列表)`
  - 静态私有方法：解决静态方法之间重复代码：`private static 返回值类型 方法名称(参数列表)`
- 常量：`public static final 数据类型 常量名称 = 数据值`，可以省略关键字；命名大写，下划线分隔；
- 接口可以作为成员变量，可以使用单独实现类，也可以使用匿名内部类，或者匿名类+匿名对象



## 多态

- 继承+重写父类方法+**父类引用指向子类对象**
- 成员方法：编译看左边，执行看右边
- 成员变量：编译运行都看左边
- 好处：无论new的是什么类，左边都不会变化
- 向上转型：就是多态，一定安全；父类引用指向子类对象；但是不能访问子类特有方法
- 向下转型：还原子类以使用特有方法，`子类名 对象名 = (子类名) 父类对象名`
- 如何知道是什么子类：`对象 isinstanceof 类名`



## final

- 可以修饰类、方法、局部变量和成员变量
  - final类**无子类**但有父类：`public final class`
  - `修饰符 final 返回值类型 方法名称(参数列表)`，不能覆盖重写；abstract和final冲突不能同时使用
  - final局部变量就是常量不能更改；可以不一开始赋值，只要赋值只有一次就行；引用的地址不可变但是值可变
  - 成员变量必须手动赋值；直接赋值或者通过方法赋值，必须保证所有方法都进行赋值



## 权限修饰符

- public>protected>(default)>private
- 同一个包里只有private不能访问
- 不同包(即使是子包)也是2个包的子类，只能访问public和protected
- 不同包不同子类只能访问public



## 内部类

- 位于在类的内部；分为成员内部类和局部内部类(包含匿名内部类，只在方法内部定义)

- 成员内部类：把内部定义的类看作是成员变量因此而命名

  - 内可以随意用外，外用内需要借助内部类对
    - 间接方法：外部类的方法中定义内部类对象，main调用外部类方法
    - 直接方法：`外部类名.内部类名 对象名 = new 外部类名().new 内部类名`
  - 访问外部类的同名变量：外部类名.this.变量名

- 局部内部类

  - 定义类和创建对象全在方法内
  - 修饰符什么都不能写
  - 如果访问所在方法的局部变量，必须是有效final的，只要事实不变则可以不写final，因为局部变量跟着方法在栈内存中，而new的对象在堆内存中，且对象比变量存活时间长，因此只要值不变就可以复制使用

- 匿名内部类

  - 如果方法中需要传入一个类的对象时就可以使用匿名内部类
  - 如果接口的实现类或者父类的子类只需要使用一次，就可以省略类的定义而改为使用匿名内部类
  - `接口名称 对象名 = new 接口名称() {// 覆盖重写所有抽象方法};`

- 重载：方法名字相同，但是参数列表不同，包括参数类型、顺序、数量等，返回类型可同可不同；在编译时进行

  但是子类不能访问父类private，改成protected就可以

  如果父类没有默认构造方法，子类就必须调用super()

  ```java
  class Fruit{
      
      public void eat(){
          Sytyem.out.println('eat fruit');
      }
  }
  
  class Apple extends Fruit{
      
      @Override
      public void eat(){
          System.out.println('eat apple');
      }
  }
  ```

- 阻止继承

  ```java
  public sealed class Shape permits Rect, Circle, Triangle{
      
  }
  public final class Rect extends Shape{
      // final表示不让继承
  }
  ```

- 初始化顺序

  - 静态属性：static开头定义的属性
  - 静态方法块：static {} 剥去来的代码块
  - 普通属性
  - 普通方法块
  - 构造函数
  - 方法

```java
public class LifeCycle {
    // 静态属性
    private static String staticField = getStaticField();
    // 静态方法快
    static {
        System.out.println(staticField);
        System.out.println('静态方法快初始化');
    }
    // 普通属性
    private String field = getField();
    // 普通方法快
    {
        System.out.println(field);
    }
    // 构造函数
    public LifeCycle(){
        System.out.println('构造函数初始化')；
    }
    
    public static String getStaticField(){
        String staticField = 'Static Field Initial';
        return staticField;
    }
    
    public static String getField(){
        String field = 'Field Initial';
        return field;
    }
    // 主函数
    public static void main(String[] argc){
        new LifeCycle();
    }
}
```

- 抽象类：抽象能力弱于接口

  ```java
  public interface Dog {
      void FurColor();
  }
  
  abstract class WhiteDog implements Dog{
      public void FurColor(){
          ...
      }
      abstract void smallBody();
  }
  ```

- 包：用package解决命名冲突问题；包是没有父子关系的

  ```java
  package qiao;
  
  public class Person{
      
  }
  ```



## static

- 创建的static成员变量位于方法区的静态区中
- 静态代码块：第一次用到类时执行唯一一次；静态内容总是优先于非静态，所以静态代码块在构造方法之前执行；用来一次性地对静态成员变量进行赋值



## 包装类

- 基本数据类型没有对应的方法，因此使用包装类进行方法定义
- int对应Integer，char对应Character，其他的只是首字母大写
- 装箱：装进包装类，使用构造方法/静态方法`valueOf()`
- 拆箱：取出基本类型，使用成员方法`intValue()`
- 自动装箱拆箱(JDK1.5之后)：直接赋值给类：`Integer in = 1`; 自动转换成基本类型进行计算：`in = in + 2`;在ArrayList里有体现



## 基本数据类型与字符串之间的转换

- 除了Character类之外，其他包装类都有`parseXxx`静态方法将字符串转换为基本类型
- 转换为字符串
  - 值+""，最常用方式
  - `toString()`
  - String类中的静态方法`valueOf()`



## 可变参数

- 定义方法时使用：`修饰符 返回值类型 方法名(数据类型...变量名)`，通过增强for使用
- 底层是数组，创建不同长度数组
- 一个方法只能有**一个**可变参数，必须写在参数列表**末尾**