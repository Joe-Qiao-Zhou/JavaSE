# Junit单元测试

测试分为黑盒白盒，前者不需要写代码，后者关注具体流程，Junit属于**白盒**测试

- 传统测试使用main方法，不需要的功能需要注释掉，且测试代码不方便管理
- Junit测试步骤
  1. 定义一个测试类/测试用例：建议测试类名为**类名+Test**，包名为**xxx.test**
  2. 定义测试方法：建议方法名为**testxxx**，返回值为**void**，无参
  3. 导入**junit**依赖
  4. 方法使用**@Test**注解
  5. 可以通过颜色判断测试是否成功
  6. 也使用断言比较断言结果和测试结果：**Assert.assertEquals(a,b)**
  7. 使用**@Before**注解保证某些代码在所有代码之前执行
  8. 在需要最后执行的代码上使用**@After**注解，即使测试异常也会执行




# 反射

## 阶段

- 是框架设计的灵魂，将类的各个组成部分封装为其他对象
- JVM 在**运行时**才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁
- 主要功能
  - 在运行时判断任意一个对象所属的类
  - 在运行时构造任意一个类的对象
  - 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）
  - 在运行时调用任意一个对象的方法

- ![image-20220222222426780](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220222222426780.png)

  - 过程
     1. 通过IO读取.class文件
     2. 构建字节数组
     3. 根据字节数组创建Class对象
     4. 在内存中生成Class对象
  - 同一个字节码文件在一次程序运行过程中只会被加载**一次**
  - Class类的构造器是**私有**的，意味着无法手动new一个Class对象，只能通过JVM创建，且构造对象时需要传入一个类加载器对象
  - **newInstance()**底层调用无参构造方法，如果没有则必须获取其他有参构造方法对象


### 源代码阶段

- .java文件编译后得到.class文件，在硬盘中

- 获取Class对象：**Class.forName("全类名")**-->将字节码文件加载进内存，返回Class对象
- 多用于读取配置文件

### **类对象阶段**

- 使用类加载器**ClassLoader**将字节码文件加载到内存中
- 用**Class类对象**来描述字节码文件：包含访问权限修饰符、类名、泛型信息、接口、注解、**字段、构造器、方法**，并将后三类对应封装为**Field**对象数组、**Constructor**对象数组和**Method**对象数组
- 获取Class对象：通过类名的class属性获取-->**Class 变量名 = 类名.class**
- 多用于参数传递

### 运行时阶段

- 需要new一个对象时

- 获取Class对象：**对象.getClass()**
- 多用于通过对象获取字节码




  - 反射的好处
    - 可以在程序运行过程中操作这些对象，比如通过**.**操作符将**Method**数组中的对象取出
    - 可以解耦，提高程序可拓展性

## Class对象的获取功能

### 获取成员变量

- **Field[] getFields()**：获取所有**public**修饰的成员变量

- **Field getField(String name)**：获取**指定名称**的**public**修饰的成员变量

- 拿到成员变量去**设置**值**get()**或者**获取**值**set()**：需要传一个**对象**作为参数，因为值在对象内部

  ******java
  Field a = personClass.getField("a");
  // 要赋值得先创建Person对象作为参数传递
  Person p = new Person();
  Object value = a.get(p);
  a.set(p, "张三");

  ******

- **Field[] getDeclearedFields()**：获取**所有**成员变量，不考虑修饰符
  
  - 虽然可以打印**private**，但是不能访问，会报**IllegalAccessException**
  - 为了访问需要忽略安全检查，进行暴力反射：**a.setAccessible(true)**

### 获取构造方法

- **getConstructor()**：通过不同参数选择不同构造方法，比如**int.class**
- **getConstructors()**
- **getDeclaredConstructor()**：返回所有修饰符的构造器，如果需要使用private的构造方法也需要进行暴力反射
- **getDeclaredConstructors()**
- **constructor.newInstance()**：创建对象，传的参数跟构造器的参数一致
  - 如果是无参构造方法可以直接使用**Class对象.newInstance()**，但是已过时，现改为**类对象.getDeclaredConstructor().newInstance()**


### 获取成员方法

- **getMethod(方法名，参数列表)**：获取方法
  - 关于参数列表
    - JVM判定方法重载的依据是参数列表，包括参数类型和参数个数，不包括变量名，因此不能通过传变量名区分方法
    - 为什么要传Class对象：类型不能用来传递，要么传递值，要么传递对象/引用，对**String.class**是Class对象

- **method.invoke(对象,参数列表)**：执行方法
  - 为何要传入对象：因为方法在方法区中，所有对象共有，为了避免操作错误，必须告诉JVM要操作的对象是谁

- **getMethods()**：包括**Object**类的**public**方法，也可暴力反射
- **method.getName()**：获取方法名称

### 获取类名

- **personClass.getName()**

### 案例

需求：写一个框架，可以创建任意类对象，并执行任意方法

实现：配置文件+反射

步骤：

1. 将需要创建的对象的全类名和方法名定义配置文件中

2. 在程序中加载配置文件

   ```
   ******java
   // 创建Properties对象
   Properties pro = new Properties();
   ```



3. 使用反射技术加载类文件进内存

   ```
   ******java
   // 获取类加载器
   ClassLoader classLoader = ReflectTest.class.getClassLoader();
   InputStream is = classLoader.getResourceAsStream("pro.properties");
   pro.load(is);
   ```


4. 创建对象

   ```
   ******java
   // 获取参数
   String className = pro.getProperty("className");
   String methodName = pro.getProperty("methodName");
   // 加载类进内存
   Class cls = Class.forName(className);
   // 创建对象
   Object obj = cls.getConstructor().newInstance();
   ```


5. 执行方法

   ```
   ******java
   // 获取方法对象 
   Method method = cls.getMethod(methodName);
   // 执行方法
   method.invoke(obj);
   ```



# 注解

## 概述

- 注释给人看，注解给计算机看


- 作用分类

  - 编译检查：**@Override**

  - 编写文档：根据注解生成文档

  - 代码分析：使用反射


## 自定义注解

- 元注解：用于描述注解的注解

  - **@Target**：描述注解能作用的位置

    - ElementType取值
      - ElementType.TYPE：作用于类上
      - ElementType.METHOD：作用于方法上
      - ElementType.FIELD：作用于成员变量上

    - **@Retention**：被保留的阶段，源码或class或runtime
      - RetetionPolicy取值
        - RetetionPolicy.RUNTIME

  - **@Documented**：是否被抽取到API文档中

  - **@Inherited**：是否被子类继承

- 格式：

  ```
  ******java
  @元注解
  public @interface 注解名称{
  	属性列表/抽象方法；
  }
  ```
  
- 本质：**public interface MyAnno extends java.lang.annotation.Annotation {}**，本质上就是一个接口，默认继承Annotation接口

- 属性：接口中定义的抽象方法
  - 返回值类型
    - 基本数据类型
    - String
    - 枚举
    - 注解
    - 以上类型的数组
  - 使用时需要给属性赋值，可以使用default初始化

## 使用注解

- 获取注解中定义的属性值,大多数时候都是用来替换配置文件

- 判断是否有接口：**method.isAnnotationPresent(Check.class);**
- 获取注解对象：**reflectTestClass.getAnnotation(Pro.class);**