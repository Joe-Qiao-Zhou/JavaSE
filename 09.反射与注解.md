# Junit单元测试

## 概述

- 测试分为黑盒白盒，前者不需要写代码，后者关注具体流程，Junit属于**白盒**测试


## 使用

- 传统测试使用main方法，缺点是不需要测试的功能得注释掉，且测试代码不方便管理

  1. 定义一个测试类(测试用例)：建议测试类名`类名+Test`，包名`xxx.test`
  2. 定义测试方法：建议方法名`testxxx`，返回值`void`，参数列表空
  3. 给方法加`@Test`注解
  4. 导入`junit`依赖环境
  5. 通过判定测试结果
  6. 常使用断言，将断言结果和测试结果比较：`Assert.assertEquals(a,b)`
  7. 要保证某些代码在所有代码之前执行，则加上`@Before`注解
  8. 在需要最后执行的代码加上`@After`注解，即使测试异常也会执行




# 反射

## 概述

- 框架设计的灵魂
- 反射机制：将类的各个组成部分封装为其他对象

- ![image-20220222222426780](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220222222426780.png)

  - 源代码阶段：创建一个类得到.java文件->`javac`编译后得到.class文件，此时代码还在硬盘中
     - **获取Class对象的方式**：`Class.forName("全类名")`：将字节码文件加载进内存，返回Class对象
     - 多用于配置文件，将类名定义在配置文件中

  - **类对象阶段/反射机制**：
     - 使用类加载器`ClassLoader`将.class字节码文件加载到内存中
     - 用**Class类对象**来描述这个字节码文件：包含成员变量、构造方法和成员方法等，并对应封装为**Field**对象数组、**Constructor**对象数组和**Method**对象数组
     - **获取Class对象的方式**：通过类名的属性class获取 `Class 变量名 = 类名.class`
     - 多用于参数传递


  - 运行时阶段：new一个对象使用
     - **获取Class对象的方式**：`对象.getClass()`
     - 多用于对象的获取字节码的方式

  - 同一个字节码文件在一次程序运行过程中只会被加载一次

  - 好处
    - 可以在程序运行过程中操作这些对象，比如通过**.**操作符将**Method**数组中的对象取出
    - 可以解耦，提高程序可拓展性

## Class对象的获取功能

### 获取成员变量

- `Field[] getFields()`：获取所有`public`修饰的成员变量

- `Field getField(String name)`：获取**指定名称**的`public`修饰的成员变量

- 拿到成员变量去**设置**值`get()`或者**获取**值`set()`：需要传一个**对象**作为参数，因为值在对象内部

  ```java
  Field a = personClass.getField("a");
  // 要赋值得先创建Person对象作为参数传递
  Person p = new Person();
  Object value = a.get(p);
  a.set(p, "张三");
  ```

- `Field[] getDeclearedFields()`：获取**所有**成员变量，不考虑修饰符
  
  - 虽然可以打印`private`，但是不能访问，会报`IllegalAccessException`
  - 为了访问需要忽略安全检查，进行暴力反射：`a.setAccessible(true)`

### 获取构造方法

- `getConstructor()`：通过不同参数选择不同构造方法，比如`int.class`
- `getConstructors()`
- `getDeclaredConstructor()`：返回所有修饰符的构造器，如果需要使用private的构造方法也需要进行暴力反射
- `getDeclaredConstructors()`
- `constructor.newInstance()`：创建对象，传的参数跟构造器的参数一致
  - 如果是无参构造方法可以直接使用`Class对象.newInstance()`，但是已过时，现改为`类对象.getDeclaredConstructor().newInstance()`


### 获取成员方法

- `getMethod(方法名，参数列表)`：获取方法，参数列表为`String.class`等
- `method.invoke(对象,参数列表)`：执行方法
- `getMethods()`：包括`Object`类的`public`方法，也可暴力反射
- `method.getName()`：获取方法名称

### 获取类名

- `personClass.getName()`

### 案例

需求：写一个框架，可以创建任意类对象，并执行任意方法

实现：配置文件+反射

步骤：

1. 将需要创建的对象的全类名和方法名定义配置文件中

2. 在程序中加载配置文件

   ```java
   // 创建Properties对象
   Properties pro = new Properties();
   ```

3. 使用反射技术加载类文件进内存

   ```java
   // 获取类加载器
   ClassLoader classLoader = ReflectTest.class.getClassLoader();
   InputStream is = classLoader.getResourceAsStream("pro.properties");
   pro.load(is);
   ```

4. 创建对象

   ```java
   // 获取参数
   String className = pro.getProperty("className");
   String methodName = pro.getProperty("methodName");
   // 加载类进内存
   Class cls = Class.forName(className);
   // 创建对象
   Object obj = cls.getConstructor().newInstance();
   ```

5. 执行方法

   ```java
   // 获取方法对象 
   Method method = cls.getMethod(methodName);
   // 执行方法
   method.invoke(obj);
   ```



# 注解

## 概述

- 注释给人看，注解给计算机看


- 作用分类

  - 编译检查：`@Override`

  - 编写文档：根据注解生成文档

  - 代码分析：使用反射


## 自定义注解

- 元注解：用于描述注解的注解

  - `@Target`：描述注解能作用的位置

    - ElementType取值
      - ElementType.TYPE：作用于类上
      - ElementType.METHOD：作用于方法上
      - ElementType.FIELD：作用于成员变量上

    - `@Retention`：被保留的阶段，源码或class或runtime
      - RetetionPolicy取值
        - RetetionPolicy.RUNTIME

  - `@Documented`：是否被抽取到API文档中

  - `@Inherited`：是否被子类继承

- 格式：

  ```java
  @元注解
  public @interface 注解名称{
  	属性列表/抽象方法；
  }
  ```
  
- 本质：`public interface MyAnno extends java.lang.annotation.Annotation {}`，本质上就是一个接口，默认继承Annotation接口

- 属性：接口中定义的抽象方法
  - 返回值类型
    - 基本数据类型
    - String
    - 枚举
    - 注解
    - 以上类型的数组
  - 使用时需要给属性赋值，可以使用default初始化

## 使用注解

- 获取注解中定义的属性值,大多数时候都是用来替换配置文件

- 判断是否有接口：`method.isAnnotationPresent(Check.class);`
- 获取注解对象：`reflectTestClass.getAnnotation(Pro.class);`