# MySQL

## 操作

- 卸载
  1. 找到my.ini文件，复制datadir路径
  2. 卸载MySQL并卸载路径对应文件夹

- 相关操作

  - 配置

    - `cmd-->services.msc`

    - 管理员打开`cmd-->net start mysql`


  - 登录：`cmd-->mysql -uroot -p`


  - 退出：`exit/quit`

  - 远程登录：`mysql -hip -uroot -p`


## SQL概述

- 操作所有关系型数据库系统
- 不区分大小写，关键字尽量大写

- 注释：`-- 注释 # 注释 /*注释*/`

- 分类
  - DDL：定义Definition，针对库和表
  - DML：操作Manipulatioin，针对表中数据
  - DQL：查询Query，针对表中数据
  - DCL：控制Control，授权

## DDL

- 数据库CRUD
  - 创建Create
    - `create database (if not exists) XXX (character set XXX);`
  - 查询Retrieve
    - `show databases;`
    - `show create database mysql;`
  - 修改Update
    - `alter database XXX character set XXX;`
  - 删除Delete
    - `drop database (if exists) XXX;`
  - 使用数据库
    - 查询正在使用的数据库：`select database();`
    - 使用数据库：`use XXX;`

- 数据表CRUD
  - 创建Create
    - `create table XXX(列名1 数据类型1,...,列名n 数据类型n);`
    - 复制表：`create table XXX like XX;`
    - 常见数据类型
      - `int`
      - `double(5,2)`
      - `date` 格式为`yyyy-MM-dd`
      - `datetime` 格式为`yyyy-MM-dd HH:mm:ss`
      - `timestamp default CURRENT_TIMESTAMP` 格式为`yyyy-MM-dd HH:mm:ss`
      - `varchar(20个字符)`
  - 查询Retrieve
    - `show tables;`
    - 查询表结构：`desc XXX;`
  - 修改Update
    - 修改表名：`alter table XXX rename to XX;`
    - 修改字符集：`alter table XXX character set XXX;`
    - 添加列：`alter table XXX add 列名 数据类型;`
    - 修改列名和类型：`alter table XXX change 列名 新列名 新数据类型;` `alter table XXX modify 列名 新数据类型;`
    - 删除列：`alter table XXX drop 列名;`
  - 删除Delete
    - `drop table (if exists) XXX;`

## DML

- 添加数据
  - `insert into XXX(列名1,...,列名n) values (值1,...,值n);`
  - 除了数字类型都需要用引号包装
- 删除数据
  - `delete from XXX [where 条件];`
  - 如果无条件则删除所有数据，而且效率低
  - 最好用`truncate table XXX;`直接删除表，并创建一个新表
- 修改数据
  - `update XXX set 列名1=值1,...,列名n=值n [where 条件];`

## DQL

- `select [distinct] 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 orderby 排序 limit 分页限定;`

- 基础查询
  - 多个字段查询：`select a,b from XXX;`
  - 去除重复：`select distinct a from XXX;`
  - 计算列：`select a,b,a操作符b from XXX;`如果其中有NULL最终值也为NULL，用`ifnull(字段，替换值)`解决
  - 起别名：`select a as aa;`

- 条件查询
  - 操作符：`>,>=,<,<=,!=,<>`
  - 与运算：`and=&&=between and`，推荐写前者
  - 或运算：`列名 in (值1,值2);`
  - null不能使用操作符判断，用`is null`

- 模糊查询
  - LIKE
    - 占位符
      - _：单个字符
      - %：多个字符

- 排序查询：`order by 字段1 方式1;`默认升序ASC，降序为DESC
- 聚合函数：将一列数据作为整体进行纵向计算
  - count(列名)：计算个数，排除NULL所在的列
    - 选择不包含空的列：主键
    - `ifnull()`
    - `count(*);`不推荐
  - max：计算最大值
  - min：计算最小值
  - sum：计算和
  - avg：计算平均值
- 分组查询：`group by 列名`
  - 分组前的约束在前面用`where`添加，分组后的约束在后面用`having`添加
  - 只有having才能用聚合函数
- 分页查询：`limit 开始的索引,每页查询的条数;`
  - 开始的索引=(当前页码-1)*每页条数
  - 分页操作是“方言”，各数据库不同

## 约束

- 对表中数据限定以保证数据正确性、有效性和完整性
- 在创建时添加约束，或者创建完后添加 `motify`；
- 分类
  - 主键约束：primary key；非空且唯一
    - 删除：`alter table XXX drop primary key;`
    - 自动增长：如果是数值类型，使用`auto_increment`可以自动增长，一般配合主键一起用
      - 如果第一条没有值则从1开始
      - 如果显示赋值了下一条从该值开始
  - 非空约束：not null
  - 唯一约束：unique；为NULL的话可以重复
    - 删除：`alter table XXX drop index 列名;`
  - 外键约束：foreign key
    - 处理数据冗余情况：拆分多张表，表之间关联
    - `create table XXX(... 外键列 constraint 外键名 foreign key (外键列) references 主表名(主表列));`如果不写CONSTRAINT系统就会自动分配
    - 既不能随便删又不能随便加
    - 外键可以为NULL，但不能为不存在的值
    - 删除：`alter table XXX drop foreign key 外键名;`
    - 添加：`alter table XXX add 创建语句;`
    - 级联操作
      - 级联更新：`alter table XXX add 创建语句 ON UPDATE CASCADE`;
      - 级联删除：`alter table XXX add 创建语句 ON DELETE CASCADE`;
  - 联合主键：`PRIMARY KEY(a,b), FOREIGN KEY (a) REFERENCES XXX(a), FOREIGN KEY (b) REFERENCES XX(b);`

## 多表之间的关系

- 数据库的设计影响开发难度
- 一对一：任意一方建立外键指向另一方主键；一般会合成一张表
- 一对多：多的一方建立外键指向另一方的主键
- 多对多：通过第三张表建立联系，存储第一张和第二章的主键，同时作为外键，即联合主键

## 范式

- 设计数据库时遵循的规范；一共有6种范式，越高冗余越小；一般遵循前3种范式就行
  - 1NF：每列都是不可分割的原子；
  - 2NF：在1NF基础上消除非主属性对主码的部分函数依赖，使得其为完全依赖
    - 解决方法：拆表；把部份依赖的列拆出去
    - 目的：消除数据冗余问题
    - 函数依赖：A->B，如果通过A的值可以唯一确定B的值，则称B依赖于A；例如学号->姓名
      - 完全函数依赖：需要依赖属性组中所有属性值，例如(学号，课程名称)->分数
      - 部分函数依赖：只需要依赖属性组中某些属性值
      - 传递函数依赖：A->B, B->C
      - 码：如果在一张表中，一个属性或属性组，被其他所有属性完全依赖，则称其为该表的码
        - 主属性：码属性组中的所有属性
  - 3NF：在2NF基础上任何非主属性不依赖于其他非主属性（消除传递依赖）
    - 解决方法：拆表；把传递依赖的B->C拆出来单独成表
    - 目的：消除数据添加和数据删除的问题

## 数据库的备份和还原

- 命令行：
  - 备份：`mysqldump -u用户名 -p密码 数据库名 > 保存路径;`
  - 还原：
    - 登录数据库
    - 创建数据库
    - 使用数据库
    - 执行文件：source 文件路径
- 图形化工具：右键数据库->Export

## 多表查询

- `SELECT * FROM 表A,表B;`会返回笛卡尔积

- 查询分类

  - 内连接查询

    - 隐式内连接：使用WHERE条件

      ```sql
      SELECT 
             t1.NAME,
             gender,
             t2.NAME 
      FROM 
           emp AS t1,
           dept AS t2 
      WHERE 
            t1.dept_id = t2.id;
      ```

    - 显式内连接

      ```SQL
      SELECT 列名 FROM 表1 (INNER) JOIN 表2 ON 条件;
      ```

    - 注意事项：哪些表？查询条件？

  - 外连接查询

    - 左外连接：查询的是左表所有数据以及右表交集数据

      ```sql
      SELECT 列名 FROM 表1 LEFT (OUTER) JOIN 表2 ON 条件;
      ```

    - 右外连接

  - 子查询：查询中嵌套的查询
  
    - 不同情况
      - 子查询结果单行单列：作为条件，使用运算符`><=<>`判断
      - 子查询结果多行单列：作为条件，使用`IN`
      - 子查询结果多行多列：作为一张虚拟表在`FROM`之后用
  
  - 自关联查询：`... FROM XXX t1,XXX t2 ...`

## 事务

- 基本介绍
  - 概念：如果多个步骤被事务管理，只能同时成功或失败
  - 操作
    - 开启事务：`start transaction;`
    - 回滚：`rollback;`
    - 提交：`commit;`
  - MySQL中事务默认自动提交，一条DML语句自动提交一次事务
  - 修改默认提交方式：`SELECT @@autocommit;`，1代表自动提交，0代表手动提交
- **四大特征**
  - 原子性
  - 持久性：提交或回滚后会持久性保存
  - 隔离性：多个事务之间相互独立
  - 一致性：操作前后数据总量不变
- 隔离级别(了解)：如果多个事务操作同一批数据则会引发问题，设置不同隔离级别解决
  - 存在问题
    - 脏读：一个事务读取到另一个事务中未提交的数据
    - 不可重复读/虚读：同一个事务中两次读取到的数据不同
    - 幻读：一个事务DML所有数据，另一个事务添加了一条数据，则第一个事务查询不到自己的修改
  - 隔离级别
    - read uncommited：3种问题
      - 同时开启2个事务，第一个事务操作过后第二个事务就能看到操作后的数据
    - read commited：后2种(Oracle)
      - 同时开启2个事务，第一个事务操作过后和提交过后第二个事务看到的数据不同
    - repeatable read：第3种(MySQL)
    - 同时开启2个事务，第一个事务提交过后第二个事务也提交才能看到操作后的数据
    - serializable：串行化，解决所有问题
      - 为表加锁，类似于操作锁对象
    - 安全性越高效率越低
  - 操作
    - 查询：`select @@transaction_isolation;`
    - 设置：`set global transaction isolation level 级别字符串;`

## DCL

- 管理用户

  - 查询

    ```sql
    USE mysql;
    SELECT * FROM USER;
    ```

  - 添加：`CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';`

  - 删除：`DROP USER '用户名'@'主机名';`

  - 修改：`UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';`

    ​			`SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');`

- 授权

  - 查询：`SHOW GRANTS FOR '用户名'@'主机名';`
  - 授予：`GRANT 权限列表(ALL) ON 数据库名.表名(*.*) TO '用户名'@'主机名';`
  - 撤销：`REVOKE 权限列表(ALL) ON 数据库名.表名(*.*) FROM '用户名'@'主机名'; ` 

## 对应代码

```sql
CREATE TABLE dept
(
    id   INT PRIMARY KEY AUTO_INCREMENT,
    NAME VARCHAR(20)
);
CREATE TABLE emp
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    NAME      VARCHAR(20),
    gender    CHAR(1),
    salary    DOUBLE,
    join_date DATE,
    dept_id   INT,
    FOREIGN KEY (dept_id) REFERENCES dept (id)
);
INSERT INTO dept (NAME)
VALUES ('开发部'),
       ('市场部'),
       ('财务部');
INSERT INTO emp (NAME, gender, salary, join_date, dept_id)
VALUES ('孙悟空', '男', 7200, '2013-02-24', 1),
       ('猪八戒', '男', 3600, '2010-12-02', 2),
       ('唐僧', '男', 9000, '2008-08-08', 2),
       ('白骨精', '女', 5000, '2015-10-07', 3),
       ('蜘蛛精', '女', 4500, '2011-03-14', 1);

# 多表查询
# 隐式内连接
SELECT t1.NAME,
       gender,
       t2.NAME
FROM emp AS t1,
     dept AS t2
WHERE t1.dept_id = t2.id;
# 显式内连接
SELECT t1.NAME,
       gender,
       t2.NAME
FROM emp AS t1
         INNER JOIN
     dept AS t2
     ON
         t1.dept_id = t2.id;
# 左外连接
SELECT t1.NAME,
       gender,
       t2.NAME
FROM emp AS t1
         LEFT OUTER JOIN
     dept AS t2
     ON
         t1.dept_id = t2.id;
# 嵌套查询
SELECT *
FROM emp
WHERE emp.salary < (SELECT AVG(salary) FROM emp);
SELECT *
FROM EMP
WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');
SELECT *
FROM dept t1,
     (SELECT * FROM emp WHERE join_date > '2011-11-11') t2
WHERE t1.id = t2.dept_id;

# 事务
CREATE TABLE account(
    id INT PRIMARY KEY AUTO_INCREMENT,
    NAME VARCHAR(10),
    balance DOUBLE
);
INSERT INTO account(NAME, balance) VALUES ('张三',1000),('李四',1000);
SELECT * FROM account;
SELECT @@autocommit;
select @@transaction_isolation;

USE mysql;
SELECT * FROM user;
USE db3;
```

```sql
package Annotation;

import java.util.Date;
@SuppressWarnings("all")
@MyAnno3
public class AnnoDemo01 {
    @MyAnno3
    private int age;
    @Override
    public String toString() {
        return super.toString();
    }

    @Deprecated
    public void show1(){
        System.out.println("show1...");
    }
    @MyAnno(show1 = 1, show3 = Person.P1, show4 = @MyAnno2, show5 = {@MyAnno2, @MyAnno2})
    public void show2(){

    }
    @MyAnno3
    public void demo(){
        show1();
        Date date = new Date();
        date.getYear();
    }
}

```

```sql
insert into student (id, name, age)
values (1, 'a', 18);
show tables;
select *
from student;
alter table student
    modify add_time timestamp default CURRENT_TIMESTAMP;
insert into student (id, name, age)
values (2, 'b', 19);
delete
from student
where id = 1;
delete
from student;
update student
set birthday='2022-02-24'
where id = 1;

create table student3
(
    id      int,
    name    varchar(20),
    age     int,
    sex     varchar(5),
    address varchar(100),
    math    int,
    english int
);
insert into student3
values (1, '马云', 55, '男', '杭州', 66, 78),
       (2, '马化腾', 45, '男', '深圳', 98, 87),
       (3, '马景涛', 55, '男', '香港', 56, 77),
       (4, '柳岩', 20, '女', '湖南', 79, 65),
       (5, '柳青', 20, '男', '湖南', 86, NULL),
       (6, '刘德华', 57, '男', '香港', 99, 99),
       (7, '马德', 22, '女', '香港', 99, 99),
       (8, '德玛西亚', 18, '男', '南京', 56, 65);
# 基础查询
select *
from student3;
select name, age
from student3;
select distinct address
from student3;
select distinct name, address
from student3;
select name, math, english, math + english
from student3;
select name, math, english, math + ifnull(english, 0)
from student3;
select name, math, english, math + ifnull(english, 0) as total
from student3;
# 条件查询
select *
from student3
where age >= 20 && age <= 30;
select *
from student3
where age >= 20
  and age <= 30;
select *
from student3
where age between 20 and 30;
select *
from student3
where age in (22, 18, 25);
select *
from student3
where english is null;
# 模糊查询
select *
from student3
where name like '%德%';
# 排序查询
select *
from student3
order by math desc, english desc;
# 聚合函数
select count(english)
from student3;
select count(ifnull(english, 0))
from student3;
select max(math)
from student3;
select avg(english)
from student3;
# 分组查询
select sex, avg(math), count(id) as 人数
from student3
where math > 70
group by sex
having 人数 > 2;
# 分页查询
select *
from student3
limit 0,3;
select *
from student3
limit 3,3;
# 约束
create table stu
(
    id   int primary key auto_increment,
    name varchar(20) not null
);
select *
from stu;
insert into stu
values (null, 'a');
# 外键约束
CREATE TABLE emp
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    name         VARCHAR(20),
    age          INT,
    dep_name     VARCHAR(20),
    dep_location VARCHAR(20)
);
INSERT INTO emp (name, age, dep_name, dep_location)
VALUES ('张三', 20, '研发部', '广州'),
       ('李四', 21, '研发部', '广州'),
       ('王五', 20, '研发部', '广州'),
       ('老王', 20, '销售部', '深圳'),
       ('大王', 22, '销售部', '深圳'),
       ('小王', 18, '销售部', '深圳');
SELECT *
FROM emp;
# 数据有冗余
CREATE TABLE department
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    dep_name     VARCHAR(20),
    dep_location VARCHAR(20)
);
CREATE TABLE employee
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    name   VARCHAR(20),
    age    INT,
    dep_id INT#,
    #CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id)
);
INSERT INTO department
VALUES (NULL, '研发部', '广州'),
       (NULL, '销售部', '深圳');
SELECT *
FROM department;
INSERT INTO employee (name, age, dep_id)
VALUES ('张三', 20, 1),
       ('李四', 21, 1),
       ('王五', 20, 1),
       ('老王', 20, 2),
       ('大王', 22, 2),
       ('小王', 18, 2);
SELECT *
FROM employee;
# 错误操作
DELETE
FROM department
WHERE id = 1;
INSERT INTO employee (name, age, dep_id)
VALUES ('张三', 20, 3);
# 级联操作
ALTER TABLE employee
    DROP FOREIGN KEY emp_dept_fk;
ALTER TABLE employee
    ADD CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department (id) ON UPDATE CASCADE ON DELETE CASCADE;
# 多表关系
CREATE TABLE tab_category
(
    cid   INT PRIMARY KEY AUTO_INCREMENT,
    cname VARCHAR(100) NOT NULL UNIQUE
);
CREATE TABLE tab_route
(
    rid   INT PRIMARY KEY AUTO_INCREMENT,
    rname VARCHAR(100) NOT NULL UNIQUE,
    price DOUBLE,
    rdate DATE,
    cid   INT,
    FOREIGN KEY (cid) REFERENCES tab_category (cid)
);
CREATE TABLE tab_user
(
    uid       INT PRIMARY KEY AUTO_INCREMENT,
    username  VARCHAR(100) NOT NULL UNIQUE,
    PASSWORD  VARCHAR(20)  NOT NULL,
    NAME      VARCHAR(100),
    birthday  DATE,
    sex       CHAR(1) DEFAULT '男',
    telephone VARCHAR(11),
    email     VARCHAR(100)
);
CREATE TABLE tab_favorite
(
    rid  INT,
    DATE DATETIME,
    uid  INT,
    PRIMARY KEY (rid, uid),
    FOREIGN KEY (rid) REFERENCES tab_route (rid),
    FOREIGN KEY (uid) REFERENCES tab_user (uid)
);
SELECT *
FROM student3;
```



# redis

- 概念： redis是一款高性能的NOSQL(Not Only SQL)系列的非关系型数据库，为解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题
- 区别
  - 关系型数据库数据之间有关联关系，存储在硬盘文件中
  - NOSQL数据之间用键值对存储，没有关联，存储在内存中

- 优点
  - 开源便宜
  - 数据存储于缓存之中速度快
  - 存储形式多：key,value形式、文档形式、图片形式等
  - 扩展性强，不用join其他表

- 缺点
  - 新技术维护难
  - 不支持sql
  - 不提供关系型数据库对事务的处理

- 总结
  - 两者互补而非对立
  - 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据

- 分类：键值存储、列存储、文档型、图形数据库
- 安装
  - redis.windows.conf：配置文件
  - redis-cli.exe：redis的客户端
  - redis-server.exe：redis服务器端

## 数据结构

- redis存储的是key,value格式的数据，其中key是字符串，value有5种不同的数据结构
  - 字符串类型 string
    - 存储：`set key value`
    - 获取：`get key`
    - 删除：`del key`
  - 哈希类型 hash：map格式
    - 存储：`hset key field value`
    - 获取：`hget key field` `hgetall key`
    - 删除：`hdel key field`
  - 列表类型 list ：linkedlist格式，支持重复元素
    - 存储：可以添加一个元素到列表的头部（左边）或者尾部（右边）`lpush key value` `rpush key value`
    - 获取：`lrange key start end`，获取所有的话end传-1
    - 删除：`lpop key` ` rpop key`
  - 集合类型 set：不允许重复元素
    - 存储：`sadd key value`
    - 获取：`smembers key`
    - 删除：`srem key value`
  - 有序集合类型 sortedset：不允许重复元素，且元素有顺序；每个元素都会关联一个double类型的分数，按照分数进行排序
    - 存储：`zadd key score value`
    - 获取：`zrange key start end [withscores]`
    - 删除：`zrem key value`
  - 通用命令
    - 查询所有的键：`keys *`
    - 获取键对应的value的类型：`type key`
    - 删除指定的key value：`del key`

## 持久化

- RDB：默认方式，不需要进行配置；在一定的间隔时间中，检测key的变化情况，然后持久化数据
  1. 编辑redis.windwos.conf文件：`save 900 1`：900秒后如果至少1个key变化了就存储
  2. 重新启动redis服务器，并指定配置文件名称：`redis-server.exe redis.windows.conf	`
- AOF：日志记录方式，可以记录每一条命令操作，并在每一次命令操作后持久化数据
  1. 编辑redis.windwos.conf文件：
     - `appendonly yes`开启持久化
     - `# appendfsync always` ：每一次操作都进行持久化
     - `# appendfsync everysec` ：每隔一秒进行一次持久化
     - `# appendfsync no`：不进行持久化

# Jedis

- `Jedis jedis = new Jedis("localhost",6379); jedis.close();`

- jedis连接池：JedisPool

  1. 配置

     ```java
     JedisPoolConfig config = new JedisPoolConfig();
             config.setMaxTotal(50);
             config.setMaxIdle(10);
     ```

  2. 创建JedisPool连接池对象：`JedisPool jedisPool = new JedisPool(config, "localhost", 6379);`

  3. 调用方法 getResource()方法获取Jedis连接

  4. 使用与归还同上
