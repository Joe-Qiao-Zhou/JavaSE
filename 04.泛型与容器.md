# 泛型

## 泛型介绍

- 泛型是一种模板技术，**将参数类型也看作一个参数**
- 泛型无法抽取基本类型
  - 泛型就是为了解决引用类型强转易出错的问题
  - 能通过自动拆装箱将基本类型转为引用类型
  - **类型擦除**使得底层还是Object，基本类型无法对其赋值

- 泛型的作用
  1. 抽取代码模板：代码复用并可通过指定类型参数与编译器**达成约定**
  2. 类型校验：**编译时**阻止不匹配元素进入Object[]，将错误提前到编译期
  3. 类型强转：根据泛型自动强转（多态，向下转型），降低错误风险


## 实现机制

- Java并不能直接实现泛型数组，内部还是Object[]
- 泛型的实际类型参数告诉**编译器**内部应存什么类型，编译器做好对应的语法约束，比如只能添加特定类型，获取值的类型也是固定的
- 编译器用泛型来限制存入和强制转出，**对容器的使用进行了强制约束**，但容器本身并没有发生实质性改变，因此虚拟机无感知，看到的仍是Object
- 泛型其实是**确定**的，容器对象类型始终是Object，元素类型是用户指定的也是确定的

## 泛型与多态

- 泛型的实现离不开多态，因为要做到无论传什么类型，模板都能接收
- 代码模板的本质就是**用Object接收一切对象，用泛型+编译器限定特定对象，用多态支持类型强转**

## 泛型方法

- 泛型类的方法不是泛型方法
- 泛型类由于在编译期就过早地确定了泛型的具体类型，所以失去了可变性，为了延迟T的确定，需要使用泛型方法
- 一般来说，一个类拥有多个同类型方法时使用泛型类，一个方法处理多种类型时使用泛型方法

- 含有泛型的方法：`修饰符 <泛型> 返回值类型(泛型)`，在调用时确定
  - 含有泛型的接口：`public interface 接口名<泛型>`
  - 使用：定义实现类时指定泛型 or 实现类继续使用泛型

## 泛型通配符

- 常用通配符：**T,E,K,V,?**，分别表示type，key-value，element和不确定类型

- 左右两边的泛型要一致，推荐右边不写，这样能在编译期就发现错误，同时左边限制了泛型的**指向**

- 指向和存取是相互限制的，放宽指向的类型返回就会导致禁止存入，而为了实现存取功能也必须限定指向的类型

- 受限泛型：设置上下限

  - `<? extends E>`表示只能使用E类型子类/本身
  - `<? super E>`表示只能使用E类型父类/本身

  - `List<? extends Number>`
    - 指向：允许指向子类型的List，如Integer和Long
    - 存入：禁止存入，防止出错，因为编译期并不知道要存什么类型
    - 取出：直接转Number类型
    - 适合Producer

  - `List<? super Integer>`
    - 指向：只能指向父类型List，比如List<Number>、List<Object>
    - 存入：只能存Integer及其子类型元素
    - 取出：只能转Object
    - 适合Consumer

  - `List<?>`
    - 指向：指向所有类型
    - 存入：禁止存入
    - 取出：Object




# 容器

## Collection

![image-20220224100712505](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220224100712505.png)

- 容器按照存储结构可以分为`Collection`和`Map`，前者存储**元素集合**，后者存储**键值对**，容器**长度可变**
- `Collection`包括
  - `List`接口：有序，有索引，能重复；包括`Vector`(由于是同步访问所以不常用)、`ArrayList`(数组实现，查询快增删慢)和`LinkedList`(链表实现，查询慢增删快)
  - `Set`接口：无序，无索引，不能重复；包括`HashSet`(哈希表+红黑树)->`LinkedHashSet`(哈希表+链表，有序)、`TreeSet`(二叉树实现，一般用于排序)
  - 常用方法：add()remove()contains()isEmpty()size()toArray()

### Collections工具类

- `Collections.addAll(集合，元素)`：往集合中添加一些元素
- `Collections.shuffle(集合)`
- `sort(集合)`：默认是升序，自定义类型要实现**comprable接口**，重写compreTo()方法，`this.val - o.val`是升序方式
- `sort(集合，Comparator<? super T>)`：按指定规则排序，比较两个对象，但是没有this指针

### Iterator

- 主要用于遍历元素
- `hasNext()`用于判断，`next()`用于取出；指针最初指向-1索引，先取再移
- 作为接口无法使用，但是Collection的实现类有成员方法`iterator()`可以返回一个迭代器对象

### LinkedList

- 双向链表实现；增删快，包含大量操作首尾元素方法：【add/get/remove】【First/Last】、pop()、push()、isEmpty()、clear()

### HashSet

- 无序，不能用fori
- 底层是哈希表，查询快
- 哈希表=数组+链表，数组初始容量为16，存储哈希值，链表/红黑树用于把这些相同哈希元素链接在一起；1.8之后=数组+红黑树，如果超过8个就会转为红黑树，横着是数组，竖着是链表
- 为何不能重复：存储前先计算哈希值，如果存在使用equals()比较内容，相同则不存储；要存储的类对象必须重写`hashCode()`和`equals()`，才能计算哈希值并比较

### LinkedHashList

- 底层是哈希表+链表，多了一条链表，用来记录元素存储顺序保证有序 



## Map

- 常用方法：`V put(K, V)、V get(K)、V remove(K)、boolean containsKey(K)、Set Values()、Set keySet()、Set entrySet()`

  - 若put的K不重复则返回空，否则返回被替换值
  - 后两个方法用来遍历集合
    - **keySet将Map的所有key取出存在一个Set里**
    - entry是键值对，将其取出放在Set集合中，Entry对象有`getKey()`和`getValue()`方法


  ```java
Set<Map.Entry<string, Integer>> set = map.entrySet();
  ```

### HashMap

- 根据键的哈希值存储数据

### Properties

- Hashtable与HashMap相比，不能存储null值null键
- 单线程操作，已被HashMap取代，但其子类Properties还在使用

## 集合添加of()

- 原本对于单列集合使用`add()`，双列集合使用`put()`，JDK9对List、Set、Map定义了静态方法`of()`添加元素
- 前提是集合元素个数确定，即只能**一次性**添加完
- 不适用于接口实现类，只适用于三个抽象接口
- 返回值是个不能改变的集合，不能再使用add、put方法
- Set和Map在使用of()时不能有重复元素



# Stream流

## 概述

- 将集合和数组转换为Stream流，并简化相关操作：只关注做什么，不关注怎么做；使用更好的方式取代for循环

- 流水线思想：得益于Lambda表达式的延迟执行，直到最后方法执行时元素才会被处理

- Stream流是一个集合元素的函数模型，**不是集合也不是数据结构**

- 与Collection操作不同的2个基础特征：

  - PipeLining：中间操作返回流对象本身
  - 内部迭代：不需要Iterator和增强for

## 获取流

- 所有的`Collection`集合都能通过`stream()`方法获取流
- `Stream`接口的静态方法`of()`可以将数组转换为流：`Stream<String> stream = Stream.of("a", "b", "c", "d", "e");`

## 常用方法

- 格式：`容器.stream().延迟方法(Lambda).终结方法(Lambda)`

- 延迟方法：返回Stream接口自身类型，支持链式调用
  - `filter()`：流只能被使用一次，使用完后数据就去往下一个流中
  - `map()`：将流中元素映射到另一个流中
  - `limit()`：只取前几个
  - `skip()`：跳过前几个
  - `concat()`：合并2个流
- 终结方法：
  - `count()`：同Collection`size()`方法，统计元素个数
  - ``forEach()`