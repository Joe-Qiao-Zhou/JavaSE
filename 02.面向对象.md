# 面向对象

## 存储机制

- 一个.java文件中只能有**一个public class**

- 分为5个部分
  - **栈内存**
    - 存储基本数据类型和对象引用，即存放变量
    - 存放各种方法
    - 如果存放的是非静态基本类型数据，则将变量名和值存入栈内存中
    - 如果是引用类型，则将变量名存入栈，并指向堆中new的对象
    - **方法在栈中运行**，存储方法的局部变量
  - **堆内存**：存储new出来的对象，数据均有默认值
  - **方法区**：存储.class信息，包含**方法**信息，因为所有对象的方法都是一样的，所以只存一份
  - 本地方法栈：与OS相关
  - 寄存器：与CPU相关

![image-20211208104752769](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211208104752769.png)

![image-20211208142237996](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211208142237996.png)



## 成员变量和局部变量

- 根据static修饰，成员变量可分为实例属性和类属性

- 根据定义位置，局部变量可分为形参、方法局部变量和代码块局部变量

- 允许两者重名，执行方法时使用局部变量

- | 区别     | 成员变量                         | 局部变量               |
  | -------- | -------------------------------- | ---------------------- |
  | 定义位置 | 类范围                           | 方法范围               |
  | 初始化   | 无需显式初始化                   | 除形参外必须显式初始化 |
  | 修饰符   | public、private、static、final   | final                  |
  | 存储位置 | 静态变量在方法区，实例变量在堆区 | 均在栈区               |
  | 生命周期 | 对象创建与垃圾回收               | 方法进出栈             |



## 标准类/Java Bean

- 所有属性均为private
- 成员属性使用get/set访问，遵守命名规范
- 具有无参构造方法
- 实现序列化接口
- 当一个POJO可序列化，有一个无参构造方法，且使用getter/setter访问属性时，就是一个JavaBean



## 继承

- 单继承+多级继承
- 子类拥有父类对象**所有**的属性与方法(包括私有)，但**无法访问**
- 子类构造方法**默认隐含无参**super()方法，先父后子，有参需要重载，且super()必须是**第一句**
- 如果父类构造函数中有打印名字，子类构造函数中无，最终打印的还是子类的名字，因为是将**子类的this一直向上传**，父类构造函数接收到的还是子类的this，因此打印的是this的名字即子类名
- 初始化顺序
  1. 父类的静态变量和静态代码块
  2. 子类的静态变量和静态代码块
  3. 父类的成员变量和普通代码块
  4. 父类的构造函数
  5. 子类的成员变量和普通代码块
  6. 子类的构造函数




## **重写**

- 子类对父类的更改，必须保持返回值类型、方法名、参数列表**完全一致**，用`@Override`标识
- 父类方法访问修饰符为private/final/static时不能重写
- 而**重载**则是参数类型、个数、顺序至少一个**不同**时

| 区别       | 重载     | 重写           |
| ---------- | -------- | -------------- |
| 范围       | 同一类   | 子类           |
| 参数列表   | 必须修改 | 不能修改       |
| 返回类型   | 可修改   | 原类型或子类型 |
| 异常       | 可修改   | 原类型或子类型 |
| 访问修饰符 | 可修改   | 不能小于原权限 |
| 发生阶段   | 编译期   | 运行期         |



## 抽象类

- 抽象方法定义：`abstract关键字+无{}`
- 抽象类中不一定有抽象方法，但含有抽象方法的类必须声明为抽象类
- 抽象类**不能**直接创建对象，必须有子类继承，子类必须重写**所有**抽象方法
- 与接口的差别
  - 子类只能继承**一个抽象类**，但能实现**多个接口**
  - 接口中全是抽象方法，没有构造方法，没有普通成员变量/可以有静态成员变量，没有静态方法
  - 抽象是对类的抽象，而接口是对行为的抽象



## 接口

- 比抽象类**更纯粹**，没有成员变量，只定义方法而不实现
- 方法冲突时，选择**更具体**的执行，比如子类方法，或者子接口方法，如果分不出则必须重写
- 字段和方法默认都是public，字段默认static（不属于对象）+final（不被实现类修改）
- java7可包含public static final修饰的常量和抽象方法，8可包含默认方法、静态方法，9可包含普通私有和静态私有方法
- 接口不能有**静态**代码块和**构造**方法
- 默认方法：public default，**含有方法体**
  - 原因：接口升级后多了一个抽象方法，而投入使用的实现类无法跟着重写新方法就会导致错误，因此需要加入方法体
- 私有方法：**默认方法**之间**重复**的内容抽取出来，为避免实现类实现类也可以调用，要定义为private
  - 普通私有方法：解决默认方法之间重复代码：`private 返回值类型 方法名称(参数列表)`
  - 静态私有方法：解决静态方法之间重复代码：`private static 返回值类型 方法名称(参数列表)`
- 接口与抽象类区别
  - 设计层面抽象类是IS-A关系，而接口是LIKE-A关系
  - 使用上一个类可实现多个接口，但只能继承一个抽象类
  - 接口字段只能是static+final，而抽象类字段无此限制
  - 接口成员只能是public，而抽象类成员可以有多种访问权限
  - 需要让不相关的类实现一个方法，如compareTo()，或需要多级继承时使用接口
  - 需要在相关类间共享代码，需要控制访问权限，需要继承非静态和非常量时使用抽象类
  - 但多数情况下，接口优于抽象类




## 多态

- 继承+重写父类方法+**父类引用指向子类对象**
- 方法具有多态性，重写了父类的就执行子类的，没重写就执行父类的，且不能调用**子类独有**的方法
- 属性不具有多态性
- 向下转型：还原子类以使用特有方法，`子类名 对象名 = (子类名) 父类对象名`
- 如何知道是什么子类：`对象 isinstanceof 类名`



## final

- 可以修饰类、方法、局部变量和成员变量
  - final类**无子类**有父类
  - final修饰的方法不能重写，abstract和final不能同时使用
  - final局部变量就是常量，可以不一开始赋值，赋值只有一次，引用地址不可变但是值可变
  - 成员变量必须手动赋值，直接赋值或者通过方法赋值，必须保证所有方法都进行赋值



## 权限修饰符

- public>protected>(default)>private
- 类中不想被序列化的变量使用**transient**修饰



## 内部类

- 类定义在哪，作用范围就在哪，内部可以随意访问外部任何内容，但外部不能访问内内部
- 静态内部类，同静态属性
- 成员内部类：将该类视作成员变量而得名
  - 内部类可以直接使用外部类的私有属性，外部类操作内部类的内容需要借助内部类对象
    - 间接方法：外部类的方法中定义内部类对象，main调用外部类方法
    - 直接方法：`外部类名.内部类名 对象名 = new 外部类名().new 内部类名`
  - 访问外部类的同名变量：`外部类名.this.变量名`
- 局部内部类

  - 写在外部类的某个代码块或方法中
  - 如果只在某个方法或块中创建这个类的某些对象，可以使用局部内部类
- 匿名内部类

  - 如果方法中需要传入一个类的对象时就可以使用匿名内部类
  - 如果接口的实现类或者父类的子类**只使用一次**，就可以省略类的定义而改为使用匿名内部类
  - `接口名称 对象名 = new 接口名称() {// 覆盖重写所有抽象方法};`
- 初始化顺序

  - 静态属性
  - 静态方法块
  - 普通属性
  - 普通方法块
  - 构造函数
  - 方法

```java
public class LifeCycle {
    // 静态属性
    private static String staticField = getStaticField();
    // 静态方法快
    static {
        System.out.println(staticField);
        System.out.println('静态方法快初始化');
    }
    // 普通属性
    private String field = getField();
    // 普通方法快
    {
        System.out.println(field);
    }
    // 构造函数
    public LifeCycle(){
        System.out.println('构造函数初始化')；
    }
    
    public static String getStaticField(){
        String staticField = 'Static Field Initial';
        return staticField;
    }
    
    public static String getField(){
        String field = 'Field Initial';
        return field;
    }
    // 主函数
    public static void main(String[] argc){
        new LifeCycle();
    }
}
```



## static

- 创建的static成员变量位于方法区的静态区中
- 静态代码块
  - 第一次用到类时执行唯一一次
  - 静态内容总是优先于非静态，所以静态代码块在**构造方法之前**执行
  - 用来一次性地对静态成员变量进行赋值

- static：用来处理通用数据，与具体对象无关
  - static变量：大家都有，不是差异化数据
  - static方法：该方法不处理差异化数据

- 因为java在调用静态方法时不会传入this，所以无法处理对象



## 包装类

- 基本数据类型没有对应的方法，因此使用包装类进行方法定义
- int对应Integer，char对应Character，其他的只是首字母大写
- 装箱：装进包装类，使用构造方法/静态方法`valueOf()`
- 拆箱：取出基本类型，使用成员方法`intValue()`
- JDK1.5之后可以自动装箱拆箱，可以将基本数据类型直接赋值给包装类：`Integer in = 1`



## 基本数据类型与字符串之间的转换

- 除了Character类之外，其他包装类都有`parseXxx`静态方法将字符串转换为基本类型
- 转换为字符串
  - 值+""，最常用方式
  - `toString()`
  - String类中的静态方法`valueOf()`



## 可变参数

- 定义方法时使用：`修饰符 返回值类型 方法名(数据类型...变量名)`，通过增强for使用
- 底层是数组，创建不同长度数组
- 一个方法只能有**一个**可变参数，必须写在参数列表**末尾**