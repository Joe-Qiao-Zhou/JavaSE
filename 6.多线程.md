# 多线程

## 并发与并行

- 并发：同一时间段内发生，CPU交替执行
- 并行：同一时刻发生，CPU同时执行



## 进程与线程

- 进程：一个应用程序可以有多个进程，是程序的一次执行过程，在内存中，是系统运行程序的基本单位
- 线程：进程的一个执行单元，一个进程至少有一个线程



## 线程调度

- 分为分时调度和抢占式调度，ava采用抢占式



## 创建多线程

- 继承Thread类并重写`run()`方法
- 创建实现类对象，调用`start()`启动，只能启动一次
- 系统会为每一个线程分配一个独立的栈空间
- ![image-20220122233301876](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220122233301876.png)
- 常用方法
  - `String getName()`：获取当前线程的名称
  - `getCurrentThread()`：获取当前线程
  - setName()：设置线程名称，或者带参数的构造方法
  - `sleep(long millis)`：使当前正在执行线程以指定毫秒数暂停



## Runnable接口创建多线程

- 实现Runnable接口的类，重写`run()`方法
- 将创建的实现类对象赋值给Thread类的构造参数执行`start()`方法
- 好处
  - 避免了单继承的局限性
  - 将设置线程任务和开启新线程进行**解耦**



## 匿名内部类实现多线程

- 简化代码，将继承重写和创建合成一步

```java
    public static void main(String[] args) {
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName() + "->" + i);
                }
            }
        }.start();

        Runnable r = new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName() + "接口->" + i) ;
                }
            }
        };
        new Thread(r).start();

        new Thread(new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName() + "简化接口->" + i) ;
                }
            }
        }).start();
    }
```



## 线程安全

- 执行if语句会使得当前线程失去cpu执行权，并且在访问共享数据时其他线程只能等待

- 使用同步技术解决

  1. 在Runnable接口实现类中使用同步代码块，这样接收该实现类对象创建的线程就会共享锁对象

     ```java
     synchoronized(同步锁){
         代码;
     }
     ```

     同步锁可以是任意对象

  2. 同步方法(可以是静态方法)

     ```java
     public synchronized void method{
         代码;
     }
     ```

     同步方法中的锁对象是**this**，本类的class属性->class文件对象(反射)

  3. 锁机制

     - 创建一个Reentrantlock对象：`Lock l = new ReentrantLock();`
     - 在同步代码前使用`lock()`方法加锁
     - 在代码后使用`unlock()`方法解锁，并将其放在finally代码块中保证永远能释放锁对象



## 线程状态

- ![image-20220123144245835](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220123144245835.png)

- 等待状态是指一个线程调用`wait()`方法，等着被另一个线程通过`notify()`方法唤醒，两个线程必须用同步代码块包装，保证只有一个执行
- 等待唤醒通信机制：两个线程都有个private成员变量作为锁对象



## 线程池

- 避免创建许多线程降低系统效率

- 本质是个容器，可以用集合存储(`ArrayList、HashSet、LinkedList<Thread>、HashMap`)

- 程序第一次启动时创建多个线程，使用时从中取出使用，`list.remove(0)`、`LinkedList.removeFirst()`

- 使用完毕后使用`add/addLast()`

- JDK1.5之后内置了线程池

  ```java
  // 生成固定数量线程池，返回值为ES接口的实现类对象
  ExecutorService es = Executors.newFixedThreadPool(2);
  // 创建一个类实现Runnable接口，重写run方法设置任务
  // 调用ES中的方法submit传递任务，开启线程执行run方法
  es.submit(new MyRunnable());
  es.submit(new MyRunnable());
  es.submit(new MyRunnable());
  ```
