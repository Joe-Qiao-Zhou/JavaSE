# Java概述

## **介绍**

- 半编译半解释
  - Java编译器**javac**先将代码**编译**为.class文件/字节码，然后由JVM**解释**执行
  - 其他编译型语言则是将代码直接编译成**机器码**执行，不同CPU指令集对应不同机器码
  - Java则针对不同平台编写**虚拟机**，虚拟机**加载字节码解释执行**
  - 但其实硬件对于机器码也是解释执行的，因此所有语言最终都是解释执行的；而编译的本质是将高级语言转换为低级语言，javac的功能就已经满足了这一特性，因此还是倾向于说Java是门**编译型语言** [Ref](https://www.zhihu.com/question/19608553/answer/14702010)

- 分为JavaSE(包含标准的JVM和标准库)、JavaEE(虚拟机与SE相同)、JavaME

## **缩写**

- ![img](https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190114161305916-1522316322.png)

- JVM：Java Virtual Machine，Java虚拟机；里面包括JVM和Java运行时基本类库rt.jar，可以理解为Java源码打成的jar包
- JRE：Java Runtime Environment，Java**运行**环境；没有编译器、调试器等开发工具，提供JVM在解释时需要调用的核心类库；**JVM/bin+lib=JRE**
- JDK：Java SE Development Kit，Java标准开发包，里面包括编译和运行Java程序所需的各种工具与资源，包括Java编译器、Java运行时环境和常用的Java类库等；


- JSR：用于定义接口的规范，参考实现RI，兼容性测试套件TCK


- JSP：审核JSR的机构

## **安装与配置**

- https://www.runoob.com/w3cnote/windows10-java-setup.html https://www.java.com/zh-CN/download/help/path.html

## **运行**

- `javac xx.java` 

  `java xx/xx.java`

## **Java特点**

- 无C++多继承、指针、内存管理等
- 不用手动管理对象生命周期
- 功能强大、简单易用、各种框架
- 静态语言：需要指定变量类型
- 平台独立性和可移植性：write once, run anywhere，通过JVM完成跨平台：**将代码编译为.class文件->打包成.jar文件**
- 容易实现多线程
- 高性能：编译器编译为字节码
- 健壮性：强类型机制、异常处理、垃圾自动收集
- 容易开发分布式项目



# IDEA

## 快捷键

- |                  |                               |
  | ---------------- | ----------------------------- |
  | `Alt+Enter`      | 导入需要的包/自动生成局部变量 |
  | `Ctrl+Y/D`       | 删除所在行/添加               |
  | `Ctrl+Alt+L`     | 格式化                        |
  | `Ctrl+Alt+T`     | 加try catch等                 |
  | `Ctrl+/`         | 单行注释                      |
  | `Ctrl+Shift+/`   | 多行注释                      |
  | `Alt+Ins`        | 自动生成代码                  |
  | `Alt+Shift+箭头` | 移动代码                      |
  | `Shift+F6`       | 统一重命名                    |

## Debug

- 逐行执行代码
- 左键单击添加断点，哪里有bug添加到哪
- 右键选择debug执行
- F8逐行执行，F7进入方法，shift+F8跳出方法，F9跳到下一个断点/结束程序，`ctrl+F2`退出debug
- 在方法体或者方法定义处添加断点都行



# 基本语法

## **数据类型**

- 四类八种

<img src="C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211205220629256.png" alt="image-20211205220629256" style="zoom: 50%;" />

- float和long类型需要在后面加上标识

## 数据定义

- 加上`final`修饰符表示**常量**，数据常量指向位置不变，但值可以变

- `var`关键字用来**省略类名**

  ```java
  StringBuilder sb = new StringBuilder();
  var sb = new StringBuilder();
  ```

- **整数运算永远是精确的**，因为只存储整数部分；而浮点数由于二进制表示问题无法达到精确

- **空字符串""和null不同**，null表示还没有指向任何内存空间

- 对于引用类型而言，==是判断是否**指向同个对象**，要想判断内容相等得用**equals()**

## 数组

- 几种创建方式

  ```java
  // 1.先声明再分配空间最后赋值
  int[] arr;
  arr = new int[5];
  arr = {1,2,3,4,5};
  
  // 2.声明并分配空间，再赋值
  int[] arr = new int[5];
  arr = {1,2,3,4,5};
  
  // 3.声明分配赋值同时进行
  int[] arr = new int[]{1,2,3,4,5};
  int[] arr = {1,2,3,4,5};
  ```

- `spiralOrder(数组)`：用于顺时针打印螺旋矩阵

## 逻辑运算符

- 短路与`&&`、短路或`||`：先看第一个元素
- 逻辑与`&`、逻辑或`|`
- 按位运算符：与`&`、或`|`、非`~`、异或`^`

## 执行控制流程

- switch语句的简洁写法，不需要写`break`；且可以使用`yield()`方法执行新线程

  ```java
  public class Main {
      public static void main(String[] args) {
          String fruit = "orange";
          int opt = switch (fruit) {
              // case "apple":
                  // 执行语句;
                  // break;
              case "apple" -> 1;
              case "pear", "mango" -> 2;
              default -> {
                  int code = fruit.hashCode();
                  yield code; // switch语句返回值
              }
          };
          System.out.println("opt = " + opt);
      }
  }
  ```



# 面向对象

## !!!内存!!!

- **一个.java文件中只能有一个public class**

- 分为5个部分
  - 栈内存：**方法在栈中运行**，只存储基本数据类型和对象引用
  - 堆内存：new出来的对象，均有地址值，数据均有默认值
  - 方法区：存储.class信息，包含**方法**信息
  - 本地方法栈：与OS相关
  - 寄存器：与CPU相关
- ![image-20211208104752769](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211208104752769.png)

- ![image-20211208142237996](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211208142237996.png)

## 成员变量和局部变量

- 定义位置不一样；作用范围不一样；**成员变量有默认值**，而局部变量没有；内存位置不一样；生命周期不一样：方法进出栈，对象创建与垃圾回收；
- private属性可以被public方法调用；private方法可以被public方法在类内部调用；

## 标准类/Java Bean定义

- 所有成员变量均用private修饰
- 为每个成员变量创建一对set/get方法
- 具有无参构造方法
- 实现序列化接口

## 匿名对象

-  `new 类名().变量/方法`

## 继承

- 单继承+多级继承
- 如果方法重名，看new的是谁就优先用谁的方法
- 如果直接访问成员变量则看左边；如果通过成员方法访问则看属于谁；如果重写了就看new的谁
- 子类构造方法默认隐含super()方法，先父类后子类；但是默认是无参的，有参需要重载；super()必须是**第一句**
- this()可以用在构造方法调用其他构造方法中，但是必须是第一句，且不能和super()**一起用**
- ![image-20211210110004661](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211210110004661.png)

## **重写**

- 子类对父类的更改，必须保持**完全一致**，用`@Override`注解来标识
- 子类访问权限**不能低于**父类：public>protected>(default)>private
- 返回值必须**小于等于**父类：Object>String

## 抽象类

- 抽象方法定义：`abstract关键字+无{}`
- 含有抽象方法的类**必须**声明为抽象类，类前也要加上abstract，**可以定义普通方法**
- 抽象类**不能**直接创建对象；必须有子类继承；子类必须重写所有抽象方法，如果没有全部重写则必须声明为抽象类
- 与接口的差别：
  - 子类只能继承**一个抽象类**，但能实现**多个接口**
  - 接口中全是抽象方法，没有构造方法，没有普通成员变量/可以有静态成员变量，没有静态方法


## 接口

- 只定义方法而不实现
- java7可包含常量和抽象方法，8可包含**默认方法**、静态方法，9可以包含私有方法
- 抽象方法的关键字必须是**pubic abstract**，两者都可以省略
- 通过实现类使用，重写所有抽象方法
- 实现类可以**实现多个接口**；如果接口抽象方法名称重复，实现一个就行；如果接口默认方法名称重复，要重写
- 接口不能有**静态**代码块和**构造**方法
- 默认方法：public default，**含有方法体**；
  - 原因：接口升级后多了一个抽象方法，而投入使用的实现类无法跟着重写新方法就会导致错误，因此需要加入方法体

- **静态方法**：直接通过接口来调用
- 私有方法：**默认方法**之间**重复**的内容抽取出来给其调用，而默认方法是public的导致实现类也可以调用，所以要定义为private
  - 普通私有方法：解决默认方法之间重复代码：`private 返回值类型 方法名称(参数列表)`
  - 静态私有方法：解决静态方法之间重复代码：`private static 返回值类型 方法名称(参数列表)`
- 常量：`public static final 数据类型 常量名称 = 数据值`，可以省略关键字；命名大写，下划线分隔；
- 接口可以作为成员变量，可以使用单独实现类，也可以使用匿名内部类，或者匿名类+匿名对象

## 多态

- 继承+重写父类方法+**父类引用指向子类对象**
- 成员方法：编译看左边，执行看右边
- 成员变量：编译运行都看左边
- 好处：无论new的是什么类，左边都不会变化
- 向上转型：就是多态，一定安全；父类引用指向子类对象；但是不能访问子类特有方法
- 向下转型：还原子类以使用特有方法，`子类名 对象名 = (子类名) 父类对象名`
- 如何知道是什么子类：`对象 isinstanceof 类名`

## final

- 可以修饰类、方法、局部变量和成员变量
  - final类**无子类**但有父类：`public final class`
  - `修饰符 final 返回值类型 方法名称(参数列表)`，不能覆盖重写；abstract和final冲突不能同时使用
  - final局部变量就是常量不能更改；可以不一开始赋值，只要赋值只有一次就行；引用的地址不可变但是值可变
  - 成员变量必须手动赋值；直接赋值或者通过方法赋值，必须保证所有方法都进行赋值

## 权限修饰符

- public>protected>(default)>private
- 同一个包里只有private不能访问；
- 不同包(即使是子包)也是2个包的子类，只能访问public和protected
- 不同包不同子类只能访问public

## 内部类？

- 在类的内部；分为成员内部类和局部内部类(包含匿名内部类，只在方法内部定义)

- 成员内部类：把内部定义的类看作是成员变量因此而命名
  - 内可以随意用外，外用内需要借助内部类对
    - 间接方法：外部类的方法中定义内部类对象，main调用外部类方法
    - 直接方法：`外部类名.内部类名 对象名 = new 外部类名().new 内部类名`
  - 访问外部类的同名变量：外部类名.this.变量名
  
- 局部内部类
  - 定义类和创建对象全在方法内
  - 修饰符什么都不能写
  - 如果访问所在方法的局部变量，必须是有效final的，只要事实不变则可以不写final，因为局部变量跟着方法在栈内存中，而new的对象在堆内存中，且对象比变量存活时间长，因此只要值不变就可以复制使用
  
- 匿名内部类
  
  - 如果方法中需要传入一个类的对象时就可以使用匿名内部类
  - 如果接口的实现类或者父类的子类只需要使用一次，就可以省略类的定义而改为使用匿名内部类
  - `接口名称 对象名 = new 接口名称() {// 覆盖重写所有抽象方法};`
  
- 重载：方法名字相同，但是参数列表不同，包括参数类型、顺序、数量等，返回类型可同可不同；在编译时进行

  但是子类不能访问父类private，改成protected就可以

  如果父类没有默认构造方法，子类就必须调用super()

  ```java
  class Fruit{
      
      public void eat(){
          Sytyem.out.println('eat fruit');
      }
  }
  
  class Apple extends Fruit{
      
      @Override
      public void eat(){
          System.out.println('eat apple');
      }
  }
  ```

- 阻止继承

  ```java
  public sealed class Shape permits Rect, Circle, Triangle{
      
  }
  public final class Rect extends Shape{
      // final表示不让继承
  }
  ```

- 初始化顺序

  - 静态属性：static开头定义的属性
  - 静态方法块：static {} 剥去来的代码块
  - 普通属性
  - 普通方法块
  - 构造函数
  - 方法

```java
public class LifeCycle {
    // 静态属性
    private static String staticField = getStaticField();
    // 静态方法快
    static {
        System.out.println(staticField);
        System.out.println('静态方法快初始化');
    }
    // 普通属性
    private String field = getField();
    // 普通方法快
    {
        System.out.println(field);
    }
    // 构造函数
    public LifeCycle(){
        System.out.println('构造函数初始化')；
    }
    
    public static String getStaticField(){
        String staticField = 'Static Field Initial';
        return staticField;
    }
    
    public static String getField(){
        String field = 'Field Initial';
        return field;
    }
    // 主函数
    public static void main(String[] argc){
        new LifeCycle();
    }
}
```

- 抽象类：抽象能力弱于接口

  ```java
  public interface Dog {
      void FurColor();
  }
  
  abstract class WhiteDog implements Dog{
      public void FurColor(){
          ...
      }
      abstract void smallBody();
  }
  ```

- 包：用package解决命名冲突问题；包是没有父子关系的

  ```java
  package qiao;
  
  public class Person{
      
  }
  ```


## static

- 创建的static成员变量位于方法区的静态区中
- 静态代码块：第一次用到类时执行唯一一次；静态内容总是优先于非静态，所以静态代码块在构造方法之前执行；用来一次性地对静态成员变量进行赋值

## 包装类

- 基本数据类型没有对应的方法，因此使用包装类进行方法定义
- int对应Integer，char对应Character，其他的只是首字母大写
- 装箱：装进包装类，使用构造方法/静态方法`valueOf()`
- 拆箱：取出基本类型，使用成员方法`intValue()`
- 自动装箱拆箱(JDK1.5之后)：直接赋值给类：`Integer in = 1`; 自动转换成基本类型进行计算：`in = in + 2`;在ArrayList里有体现

## 基本数据类型与字符串之间的转换

- 除了Character类之外，其他包装类都有`parseXxx`静态方法将字符串转换为基本类型
- 转换为字符串
  - 值+""，最常用方式
  - `toString()`
  - String类中的静态方法`valueOf()`

## 可变参数

- 定义方法时使用：`修饰符 返回值类型 方法名(数据类型...变量名)`，通过增强for使用
- 底层是数组，创建不同长度数组
- 一个方法只能有**一个**可变参数，必须写在参数列表**末尾**



# 常用类

## Object类

- 根类
- `toString()`：默认打印`包名类名@地址值`
- `equals()`：默认比较地址值

## Scanner类

- ```java
  Scanner sc = new Scanner(System.in);
  int num = sc.nextInt();
  System.out.println(num);
  String s = sc.next();
  System.out.println(s);
  ```

- ```java
  public static void main(String[] args) {
      // 匿名对象
      int num = new Scanner(System.in).nextInt();
      System.out.println(num);
  
      methodParam(new Scanner(System.in));
  
      int i = methodReturn().nextInt();
      System.out.println(i);
  }
  
  // 匿名对象作为方法参数
  public static void methodParam(Scanner sc){
      int i = sc.nextInt();
      System.out.println(i);
  }
  
  // 匿名对象作为方法返回值
  public static Scanner methodReturn(){
      return new Scanner(System.in);
  }
  ```

## Random类

- `nextInt()`：如果无参则取值范围很大，有参则在[0,x-1]之间随机取

  ```java
  Random r = new Random();
  int num = r.nextInt(10);
  System.out.println(num);
  ```

## ArrayList类

- **大小可变的数组**
- 支持多线程，取代了单线程的Vector
- \<E>代表泛型，即集合中所有元素的类型，只能是**引用类型**，如果想存储基本类型，必须使用对应的包装类
- 直接打印得到的不是地址而是**内容**，如果内容为空则输出[]
- 常用方法
  - `public boolean add(E e)`
  - `public E get(int index)`
  - `public E remove(int index)`
  - `public int size()`

## String类

- 内容不可变，因此可共享使用
- 效果上相当于char[]，但底层原理是byte[]
- 3种构造方法：`String() String(char[] array) String(byte[] array)`
- 字符串常量池：只要是显式赋值""的字符串就在池中，池位于堆中

​	![image-20211208214206602](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20211208214206602.png)

- ==用于比较地址值，`boolean equals(Object)`用于比较内容，`boolean equalsIgnoreCase(String)`忽略大小写
- 推荐把常量写在变量前面，因为如果变量是null的话在前面会导致空指针异常
- 常用方法：`int length() String concat(String)`
- 返回指定索引位置的字符：`char charAt(int)`
- 查找参数字符串首次出现的位置：`int indexOf(String)`
- 截取字符串： `substring(int)、substring(int begin, int end)`
- 转换字符串：`char[] toCharArray()`、`byte[] getBytes()`、 `String replace(Char oldChar, Char newChar)`
- 分割字符串：`String[] split(String regex)`，参数是正则表达式

## Arrays类

- 与数组相关的工具类，大量**静态方法**实现常用操作

  - `String Arrays.toString(数组)`

  - `String Arrays.deepToString(Object[] a)`：打印二维数组

  - `void Arrays.sort(数组)`，如果是引用类型需要实现`Comparable`接口的`CompareTo()`方法

    ```java
    class Man implements Comparable {
        int age;
        int id;
        String name;
     
        public Man(int age, String name) {
            super();
            this.age = age;
            this.name = name;
        }
     
        public String toString() {
            return this.name;
        }
     
        public int compareTo(Object o) {
            Man man = (Man) o;
            if (this.age < man.age) {
                return -1;
            }
            if (this.age > man.age) {
                return 1;
            }
            return 0;
        }
    }
    ```

  - `数据类型 Arrays.binarySearch(数组, 数据类型 key)`：必须先**排好序**才能实现二分查找，返回key对应的索引值

  - `void Arrays.fill(数组, 数据类型 val)`：全部填充为val

  - `void Arrays.fill(数组, int fromIndex, int toIndex, 数据类型 val)`：从fromIndex到toIndex**前一位**全部填充为val

## Math类

- `Math.abs()`
- `double Math.ceil()`：向上取整
- `double Math.floor()`：向下取整
- `Math.round()`：四舍五入
- `Math.PI`

## Date类

- 将日期转换为毫秒，默认时间原点为1970.1.1.00:00:00，中国为8点
- `new Date()`返回的是当前系统时间
- 输出当前时间与时间原点的毫秒值差：`System.currentTimeMillis()`
- `long getTime()`将日期转换为毫秒

## DateFormat类

- Date对象与String对象之间的转换

- 是个抽象类，使用SimpleDateFormat子类创建对象，传入字符串作为日期格式，字符串中的字母不可以更改

  ```java
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
  Date date = new Date();
  String text = sdf.format(date);
  
  String text2 = "2021年12月17日 15:42:45";
  Date date2 = sdf.parse(text2);
  ```

- 将符合模式的字符串解析为日期：`Date parse(String source)`

## Calendar类

- 抽象类，解决了很多Date类的问题
- 可以通过`Calendar c = Calendar.getInstance()`创建对象
- 常用方法：字符串被定义为静态成员变量进行Int赋值，可以传1或者Calendar.YEAR获取

  - `c.get(Calendar.YEAR)`
- `c.set(Calendar.YEAR, 9999)`
  - `c.add(Calendar.YEAR, 1)`
- `Date c.getTime()` 

## System类

- `arraycopy(src, srcpos, des, despos, length)`
- `currentTimeMillis()`：主要是测试程序运行时间

## StringBuilder类

- 字符串缓冲区，支持**可变**的字符串，没有被final修饰，默认长度为16
- **StringBuilder append()**返回this，可以是任意类型
- `String toString()`

## File类

- 为了方便不同系统间的操作，使用`String pathSeparator = File.pathSeparator`和`String separator = File.separator`代替特定符号


- 构造方法传的路径可以是文件或者文件夹，可以相对或绝对，可以存在或不存在，但是要传入\转义符；只是将其封装成File对象，**不考虑对错**


- 常用方法

  - 获取功能
    - `String getAbsolutePath()`
    - `String getPath()`
    - `String getName()`
    - `String toString()`
    - `long length()`：File对象指向文件的大小，不能获取文件夹大小，若不存在则返回0
    - `static void getAllFile(File)`

  - 判断功能
    - `boolean exists()`：
    - `boolean isDirectory()`
    - `boolean isFile()`

  - 创建删除功能
    - boolean createNewFile()：只能创建文件，路径必须存在
    - boolean delete():有内容无法删除，直接在硬盘删除
    - boolean mkdir():只能创建文件，路径必须存在；单级文件夹
    - boolean mkdirs():只能创建文件，路径必须存在；单级和多级文件夹

  - 遍历功能
    - String[] list():
    - **File[] listFiles()**
    - 递归打印所有文件夹内的文件：isDirectory()判断是否为文件夹，是的话递归调用自己


## **FileFilter**接口

- 接口无实现类，需要自己实现accept方法 

- 传递参数为过滤器：`file[] listFiles(FileFilter filter)`&`file[] listFiles(FileNameFilter filter)`

  - 两者都有accept()方法，前者参数为File，判断路径是否存在于某个列表中，后者参数File和String，判断名称是否存在

  ```java
  package filedemo;
  
  import java.io.File;
  import java.io.FileFilter;
  import java.util.Locale;
  
  public class FileFilterImpl implements FileFilter {
      @Override
      public boolean accept(File pathname) {
          if(pathname.isDirectory()){
              return true;
          }
          return pathname.getName().toLowerCase(Locale.ROOT).endsWith(".pdf");
      }
  }
  ```

  ```java
  package filedemo;
  
  import java.io.File;
  import java.io.FileFilter;
  import java.io.FilenameFilter;
  import java.util.Locale;
  
  public class Demo01Filter {
      public static void main(String[] args) {
          File file = new File("D:\\BaiduNetdiskDownload");
          getAllFile(file);
          getAllFile02(file);
          getAllFile03(file);
          getAllFile04(file);
  
      }
  
      static void getAllFile(File dir) {
          System.out.println(dir);
          File[] files = dir.listFiles(new FileFilterImpl());
          for (File f : files) {
              if (f.isDirectory()) {
                  getAllFile(f);
              } else {
                  System.out.println(f);
              }
          }
      }
  
      // 匿名内部类实现
      static void getAllFile02(File dir) {
          System.out.println(dir);
          File[] files = dir.listFiles(new FileFilter() {
  
              @Override
              public boolean accept(File pathname) {
                  return pathname.isDirectory() || pathname.getName().toLowerCase(Locale.ROOT).endsWith(".pdf");
              }
          });
          for (File f : files) {
              if (f.isDirectory()) {
                  getAllFile(f);
              } else {
                  System.out.println(f);
              }
          }
      }
  
      // 匿名内部类实现FilenameFilter
      static void getAllFile03(File dir) {
          System.out.println(dir);
          File[] files = dir.listFiles(new FilenameFilter() {
  
              @Override
              public boolean accept(File dir, String name) {
                  return new File(dir, name).isDirectory() || name.toLowerCase(Locale.ROOT).endsWith(".pdf");
              }
          });
          for (File f : files) {
              if (f.isDirectory()) {
                  getAllFile(f);
              } else {
                  System.out.println(f);
              }
          }
      }
  
      // Lambda表达式
      // 匿名内部类实现FilenameFilter
      static void getAllFile04(File dir) {
          System.out.println(dir);
          File[] files = dir.listFiles((dirs, name) ->
                  new File(dir, name).isDirectory() || name.toLowerCase(Locale.ROOT).endsWith(".pdf")
          );
          for (File f : files) {
              if (f.isDirectory()) {
                  getAllFile(f);
              } else {
                  System.out.println(f);
              }
          }
      }
  
  }
  ```



# 泛型

## 泛型

- **将参数类型也看作一个参数**，未知数据类型，用来接收数据类型，创建集合对象时就会确定泛型的数据类型
- 泛型没有继承概念
- 不使用的利弊
  - 利：Object类型可以存储任意类型
  - 弊：不安全，引发类型转换异常
- 使用的利弊
  - 利：避免类型转换，且运行期异常变为编译期异常
  - 弊：只能存储对应数据
- 定义：数据类型改为E，类后面加上\<E>
- 含有泛型的方法：`修饰符 <泛型> 返回值类型(泛型)`，在调用时确定
  - 含有泛型的接口：`public interface 接口名<泛型>`
  - 使用：定义实现类时指定泛型 or 实现类继续使用泛型


## 泛型通配符

- 不知道使用什么类型接收数据时，使用？表示
- **只能接收**数据不能存储数据，**定义时不能使用**
- 受限泛型：设置上下限
  - ? extends E 只能使用E类型子类/本身
  - ? super E 只能使用E类型父类/本身



# 容器

## Collection

![image-20220224100712505](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220224100712505.png)

- 容器按照存储结构可以分为`Collection`和`Map`，前者存储**元素集合**，后者存储**键值对**；容器**长度可变**；
- `Collection`包括
  - `List`接口：有序，有索引，能重复；包括`Vector`(由于是同步访问所以不常用)、`ArrayList`(数组实现，查询快增删慢)和`LinkedList`(链表实现，查询慢增删快)
  - `Set`接口：无序，无索引，不能重复；包括`HashSet`(哈希表+红黑树)->`LinkedHashSet`(哈希表+链表，有序)、`TreeSet`(二叉树实现，一般用于排序)
  - 常用方法：add()remove()contains()isEmpty()size()toArray()

### Collections工具类

- `Collections.addAll(集合，元素)`：往集合中添加一些元素
- `Collections.shuffle(集合)`
- `sort(集合)`：默认是升序，自定义类型要实现**comprable接口**，重写compreTo()方法，`this.val - o.val`是升序方式
- `sort(集合，Comparator<? super T>)`：按指定规则排序，比较两个对象，但是没有this指针

### Iterator

- 主要用于遍历元素
- `hasNext()`用于判断，`next()`用于取出；指针最初指向-1索引，先取再移
- 作为接口无法使用，但是Collection的实现类有成员方法`iterator()`可以返回一个迭代器对象

## LinkedList类

- 双向链表实现；增删快，包含大量操作首尾元素方法：【add/get/remove】【First/Last】、pop()、push()、isEmpty()、clear()

## Map

- 常用方法：`V put(K, V)、V get(K)、V remove(K)、boolean containsKey(K)、Set Values()、Set keySet()、Set entrySet()`

  - 若put的K不重复则返回空，否则返回被替换值
  - 后两个方法用来遍历集合
    - **keySet将Map的所有key取出存在一个Set里**
    - entry是键值对，将其取出放在Set集合中，Entry对象有`getKey()`和`getValue()`方法


  ```java
  Set<Map.Entry<string, Integer>> set = map.entrySet();
  ```

### HashMap

- 根据键的哈希值存储数据

### Properties

- Hashtable与HashMap相比，不能存储null值null键
- 单线程操作，已被HashMap取代，但其子类Properties还在使用

## HashSet

- 无序，不能用fori
- 底层是哈希表，查询快
- 哈希表=数组+链表，数组初始容量为16，存储哈希值，链表/红黑树用于把这些相同哈希元素链接在一起；1.8之后=数组+红黑树，如果超过8个就会转为红黑树，横着是数组，竖着是链表
- 为何不能重复：存储前先计算哈希值，如果存在使用equals()比较内容，相同则不存储；要存储的类对象必须重写`hashCode()`和`equals()`，才能计算哈希值并比较

## LinkedHashList类

- 底层是哈希表+链表，多了一条链表，用来记录元素存储顺序保证有序 

## 集合添加of()

- 原本对于单列集合使用`add()`，双列集合使用`put()`，JDK9对List、Set、Map定义了静态方法`of()`添加元素
- 前提是集合元素个数确定，即只能**一次性**添加完
- 不适用于接口实现类，只适用于三个抽象接口
- 返回值是个不能改变的集合，不能再使用add、put方法
- Set和Map在使用of()时不能有重复元素



# 异常

- 异常本身是一个类，产生异常就是创建异常对象并抛出
- 根类是Throwable，Error子类是不能处理只能避免的问题，Exception是使用不当导致的
- 异常分为编译期异常和运行期异常
- 异常处理方法：抛出异常交给虚拟机处理；也可try/catch，try放可能会异常代码，catch放解决方法

## 异常产生

- 产生过程：
  - JVM根据异常产生原因创建一个异常对象，包含异常产生的内容、原因和位置
  - 没有trycatch则把异常抛给调用者，比如main
  - 调用者没有处理方法则重新抛给JVM
  - JVM抛出给控制台(中断处理：打印+中止)
  - 一级级向上抛出

## 异常处理

- throw关键字：在指定的方法中抛出指定的异常

  - 格式

    ```java
    throw new xxxException("异常产生的原因");
    ```

  - 注意事项

    - 必须写在方法内部
    - new的对象必须是Exception或其子类对象
    - 抛出后必须处理，如果是runtime可以不处理交给JVM处理
    - 如果是编译异常必须处理，throws或者trycatch

  - 在实际工作中必须首先对参数进行合法性校验并抛出异常

  - 使用Objects.requiresNonNull()简化空指针异常判断

  - Throwable类中定义了3个异常处理方法：String getMessage()、String toString()、void printStackTrace()，返回的信息从略到详

## 声明异常throws

- 自己不处理，给调用者处理，在方法声明时使用

- 格式

  ```java
  修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException...{
      throw new AAAException("产生原因");
      throw new BBBException("产生原因");
  }
  ```

- 注意事项

  - 必须写在方法声明处
  - 声明的必须是异常或者异常子类
  - 如果抛出多个异常对象，也必须声明多个
  - 如果有子父类则只声明父类
  - 调用该方法则必须处理异常，要么继续在调用函数处继续throws给JVM处理，要么trycatch自己处理

## try..catch处理异常

- 为了不中断处理

- 格式

  ```java
  try{
      可能会产生异常的代码
  }catch(定义一个异常变量用于接收抛出的异常){
      异常处理逻辑，通常写入到日志文件中
  }
  ...
  catch(){}
  ```

- 注意

  - 抛出多个就catch多个
  - 出现异常执行完catch后可以继续执行程序
  - 在调用处使用try...catch

## finally代码块

- 无论是否异常都必须执行的代码
- 注意
  - 必须跟try catch一起使用，写在catch之后
  - 一般用于资源释放
  - 不要在finally中写return，因为永远会执行

## 多个异常

- 分别处理：每个异常用一个trycatch
- 一次捕获，多次处理：一个try多个catch，子类异常必须先处理
- 一次捕获，一次处理：定义一个父类异常对象接收所有异常

## 自定义异常

- 必须继承Exception或者RuntimeException
- 添加空参数构造方法和异常信息的构造方法：直接调用父类构造方法super()处理异常信息即可
- 编辑期异常必须处理



# 多线程

## 并发与并行

- 并发：同一时间段内发生，CPU交替执行
- 并行：同一时刻发生，CPU同时执行

## 进程与线程

- 进程：一个应用程序可以有多个进程，是程序的一次执行过程，在内存中，是系统运行程序的基本单位
- 线程：进程的一个执行单元，一个进程至少有一个线程

## 线程调度

- 分为分时调度和抢占式调度，ava采用抢占式

## 创建多线程

- 继承Thread类并重写`run()`方法
- 创建实现类对象，调用`start()`启动，只能启动一次
- 系统会为每一个线程分配一个独立的栈空间
- ![image-20220122233301876](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220122233301876.png)
- 常用方法
  - String getName()：获取当前线程的名称
  - getCurrentThread()：获取当前线程
  - setName()：设置线程名称，或者带参数的构造方法
  - sleep(long millis)：使当前正在执行线程以指定毫秒数暂停

## Runnable接口创建多线程

- 实现Runnable接口的类，重写run方法
- 将创建的实现类对象赋值给Thread类的构造参数进行start
- 好处
  - 避免了单继承的局限性
  - 将设置线程任务和开启新线程进行解耦

## 匿名内部类实现多线程

- 简化代码，将继承重写和创建合成一步

## 线程安全

- if语句会使得失去cpu执行权

- 在访问共享数据时其他线程只能等待

- 使用同步技术解决

  - 同步代码块

    ```java
    synchoronized(同步锁){
        代码;
    }
    ```

    同步锁可以是任意对象

  - 同步方法

    ```java
    public synchronized void method){
        代码;
    }
    ```

    同步方法中的锁对象是this

    方法可以是静态的，锁对象是本类的class属性->class文件对象(反射)

  - 锁机制

    - 在成员位置创建一个Reentrantlock对象
    - 在代码前使用lock方法
    - 在代码后使用unlock方法
    - 把unlock方法放在finally中能够永远释放锁对象

## 线程状态

- ![image-20220123144245835](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220123144245835.png)

- 等待状态是指一个线程被另一个线程唤醒，两个线程必须用同步代码快包装，保证只有一个执行
- 等待唤醒通信机制：两个线程都有个private成员变量作为锁对象

## 线程池

- 避免创建许多线程降低系统效率
- 本质是个容器，可以用集合存储(ArrayList、HashSet、LinkedList\<Thread>、HashMap)
- 程序第一次启动时创建多个线程，使用时从中取出使用，list.remove(0)、LinkedList.removeFirst()
- 使用完毕后使用add/addLast()
- JDK1.5之后内置了线程池



# 函数式编程

## Lambda表达式

- 目的只是把run中的代码给Thread，免去其他所有操作
- (参数)->{代码}，把括号内的参数传递给{}中的代码
- 可推导可省略：能够根据上下文推导的内容都可以省略：参数数据类型；一个参数的括号和类型；一行代码省略括号和**return**和分号，但必须一起省略；
- 使用前提：**必须具有接口**，且抽象方法唯一；方法参数或局部变量必须为Lambda对应的接口类型才能进行上下文推断



# IO

- 分为字符流和字节流，一切皆为字节
- close之前会flush

## 字节输出流

- OutputStream，是一个抽象类
- 常用方法
  - void close()
  - void flush()
  - void write(byte[] b)
  - void write(byte[] b, int off, int len)
  - abstract void write(int b)
  - String类中有方法getBytes()可以将字符串转化为字节数组
- 子类：FileOutputStream
  - 构造方法，参数可以为String name和File file，前者为路径，后者为文件
  - 为了追加写，需要使用带有boolean append参数的构造方法，false的话创建新文件覆盖原文件
  - 换行需要使用""\r\n.getBytes()

## 字节输入流

- 与write相对的方法为read
- 2字节读ABCDE，最后一次输出ED，因为E覆盖C而D未被覆盖

## 字符输入流

- Reader，抽象类
- 常用方法
  - int read():
  - int read(char[] c)
  - void close()
- FileReader

## 字符输出流

- 可以直接写字符串
- write过后需要flush进文件中
- close也可以刷新缓冲区，但是之后不能再用

- 续写和换行

## IO异常的处理

- 把close放在finally中，但是finally中没有fw，所以要在外面先定义，赋值为null 
- JDK7的特性：在try后加()定义流对象，执行完毕自动释放不需要写finally和close，比9方便些
- JDK9：try之前定义流对象，try后()内引入变量名，在try代码块后也可以释放

## 属性集

- 继承了hashtable，有键值均为字符串，唯一和IO流结合的集合，可以将临时数据持久写入磁盘中，也可以load将文件读取到集合中

## 缓冲流

- 增加缓冲区，提高读写效率，在之前加上Buffered
- 字节输出流：构造方法传入OutputStream，也可以加上int size
- write写入到内部缓冲区，flush刷新到文件中
- 只需关闭缓冲流
- 字符输出流BUfferedWriter：void newLine()：写入一个行分隔符
- 字符输入流BuffedReader：void readLine()：读取一行，遇到换行回车就不读，可以用!=null循环读

## 转换流

- 字符编码与字符集
- GBK2个字节存储中文，UTF8用3个
- InputStreamReader、OutputStreamWriter是FileReader和FileWriter的父类，可以指定字符集；读文件的话编码方式要和文件编码方式相同

## 序列化流

- 把对象以流的形式写入文件中就叫做对象的序列化
- ObjectOutputStream(OutputSteam out).writeObject(Object obj)
- 要进行序列化和反序列化的类必须实现**Serializable接口**，里面没有方法，只是作为标记
- ObjectInputStream：反序列化流；读的类必须实现接口，且必须有class文件
- transient关键字：与static相同，被修饰的成员变量不能被序列化
- 如果在系列化之后class文件发生了改变反序列化也不能成功，是因为每个类被赋予一个序列化id，可以在类中显性加入这个ID private static final long serialVersionID；
- 序列化集合：将多个对象存储在集合中，对集合序列化

## 打印流

- PrintStream
- setOut()方法改变输出目的地