# ~~成员变量和局部变量~~

- 属性指的是getter setter名中内容，有时候属性与成员变量不一样，如getSex()和gender

- 根据static修饰，变量可分为成员变量和类变量

- 根据定义位置，局部变量可分为形参、方法局部变量和代码块局部变量

- 允许两者重名，执行方法时使用局部变量

- | 区别     | 成员变量                         | 局部变量               |
  | -------- | -------------------------------- | ---------------------- |
  | 定义位置 | 类范围                           | 方法范围               |
  | 初始化   | 无需显式初始化                   | 除形参外必须显式初始化 |
  | 修饰符   | public、private、static、final   | final                  |
  | 存储位置 | 静态变量在方法区，实例变量在堆区 | 均在栈区               |
  | 生命周期 | 对象创建与垃圾回收               | 方法进出栈             |

# ~~标准类/Java Bean~~

- 类用public修饰
- 所有属性均为private
- 成员属性使用get/set访问，遵守命名规范
- 具有无参构造方法
- 实现序列化接口

## ~~序列化~~

- 目的：创建可复用的Java对象，一般对象生命周期不会比JVM长，为了保存以便将来使用
- 储存方式：以【字节数组】保存
- 使用场景：对内存中对象进行持久化或网络传输时
- 实现方法：实现Serializable接口，transient阻止序列化，static不会被序列化
- 指定serialVersionUID：JVM在序列化和反序列化时会根据属性自动生成UID，如果两者相同则反序列化成功，如果不显式指定，只要类有修改，旧对象的反序列化就会失败

# ~~复制~~

- 直接赋值复制：复制的是引用，两者指向同一个对象
- 浅复制：复制引用但不复制引用的对象
- 深复制：复制引用及其引用的对象，可以让其实现Serializable接口，将对象写入流中，再读取出来，便可以实现深复制

# ~~继承~~

- 单继承+多级继承
- 子类拥有父类**所有**属性与方法(包括私有)，但**无法访问**
- 子类构造方法默认隐含无参super()，先父后子，有参需要重载，且super()必须是**第一句**，因此this和super**不能同时出现**，不然super会调用2次
- 如果父类构造函数中有打印名字，子类构造函数中无，最终打印的还是子类的名字，因为是将**子类的this一直向上传**，父类构造函数接收到的还是子类的this，因此打印的是this的名字即子类名
- 初始化顺序
  1. 父类的静态变量和静态代码块
  2. 子类的静态变量和静态代码块
  3. 父类的成员变量和普通代码块
  4. 父类的构造函数
  5. 子类的成员变量和普通代码块
  6. 子类的构造函数


# ~~**重写**与重载~~

- 子类对父类的更改，必须保持【修饰符 返回值类型 方法名(参数列表)】完全一致，即外壳不变内核重写，用`@Override`标识
- 父类方法访问修饰符为【private/final/static】时不能重写
- 而**重载**则是参数列表必须修改，修饰符和返回值类型可以修改，只有方法名相同

| 区别       | 重载                 | 重写                     |
| ---------- | -------------------- | ------------------------ |
| 范围       | 同一类，本类多态体现 | 子类，父子类多态体现     |
| 访问修饰符 | 可修改               | 不能小于原权限           |
| 返回类型   | 可修改               | JDK7后可为原类型或子类型 |
| 参数列表   | 必须修改             | 不能修改                 |
| 发生阶段   | 编译期               | 运行期                   |
| 异常       | 可修改               | 原类型或子类型           |

# ~~抽象类~~

- 抽象方法定义：abstract+无方法体
- 抽象类中不一定有抽象方法，但含有抽象方法的类必须声明为抽象类
- 抽象类**不能**直接创建对象，必须有子类继承，子类必须重写**所有**抽象方法

# ~~接口~~

- 没有成员变量，只定义方法而不实现
- 方法冲突时选择**更具体**的执行，比如子类方法或子接口方法，如果分不出则必须重写
- 字段和方法默认都是public，字段默认static（不属于对象）+final（不被实现类修改）
- java7可包含public static final修饰的常量和抽象方法，8可包含默认方法、静态方法，9可包含普通私有和静态私有方法
- 接口不能有静态代码块和构造方法
- 默认方法：public default，**含有方法体**
  - 原因：接口升级后多了一个抽象方法，而已使用的实现类无法重写就会导致错误，因此需要加入方法体
- 私有方法：默认方法之间**重复**的内容抽取出来，为避免实现类调用定义为private
  - 普通私有方法：解决默认方法之间重复代码：`private 返回值类型 方法名称(参数列表)`
  - 静态私有方法：解决静态方法之间重复代码：`private static 返回值类型 方法名称(参数列表)`
- 接口与抽象类区别
  - 设计层面抽象类是IS-A关系，接口是LIKE-A关系
  - 一个类可实现多个接口，但只能继承一个抽象类
  - 抽象类是对类的抽象，接口是对行为的抽象
  - 接口字段只能是static+final，而抽象类字段无此限制
  - 接口成员只能是public，而抽象类成员可以有多种访问权限
  - 需要让不相关的类实现一个方法，如compareTo()，或需要多级继承时使用接口
  - 需要在相关类间共享代码，需要控制访问权限，需要继承非静态和非常量时使用抽象类
  - 多数情况下，接口优于抽象类


# ~~多态~~

- 继承+重写父类方法+**父类引用指向子类对象**
- 只有方法具有多态性，重写了就执行子类的，没重写就执行父类的，不能调用**子类独有**的方法

# ~~final~~

- 可以修饰类、方法、局部变量和成员变量
  - final类**无子类**有父类
  - final修饰的方法不能重写，abstract和final不能同时使用
  - final局部变量就是常量，可以不一开始赋值，赋值只有一次，引用地址不可变但是值可变
  - final成员变量在声明时初始化或者通过构造方法赋值，且所有构造方法中都要进行赋值

# ~~权限修饰符~~

- public>protected(子类可使用)>(default)(同一包内可使用)>private

# ~~内部类~~

- 内部类可访问外部内容，但外部无法访问内部内容
- 静态内部类：定义在类内部的静态类，类似于静态属性，可访问外部类的静态变量和静态方法
- 成员内部类：类似于普通属性，不能定义静态方法和静态属性
- 局部内部类：定义在代码块或方法中

- 匿名内部类：如果方法中需要传入一个对象时就可使用

- 初始化顺序

  - 静态属性
  - 静态方法块
  - 普通属性
  - 普通方法块
  - 构造函数
  - 方法

```java
public class LifeCycle {
    // 静态属性
    private static String staticField = getStaticField();
    // 静态方法快
    static {
        System.out.println(staticField);
        System.out.println('静态方法快初始化');
    }
    // 普通属性
    private String field = getField();
    // 普通方法快
    {
        System.out.println(field);
    }
    // 构造函数
    public LifeCycle(){
        System.out.println('构造函数初始化')；
    }
    
    public static String getStaticField(){
        String staticField = 'Static Field Initial';
        return staticField;
    }
    
    public static String getField(){
        String field = 'Field Initial';
        return field;
    }
    // 主函数
    public static void main(String[] argc){
        new LifeCycle();
    }
}
```

# ~~static~~

- 创建的static成员变量位于方法区中
- 静态代码块
  - 第一次用到类时执行唯一一次
  - 静态内容总是优先于非静态，所以静态代码块在**构造方法之前**执行
  - 用来一次性地对静态成员变量进行赋值

- static用来处理通用数据，与具体对象无关
  - static变量：大家都一样，**可以通过实例访问**
  - static方法：该方法不处理差异化数据

- 因为java在调用静态方法时不会传入this，所以无法处理对象

# ~~包装类~~

- 基本数据类型没有对应的方法，因此使用包装类进行方法定义
- int对应Integer，char对应Character，其他的只是首字母大写
- 装箱：装进包装类，使用构造方法/静态方法`valueOf()`
- 拆箱：取出基本类型，使用成员方法`intValue()`
- JDK1.5之后可以自动装箱拆箱，可以将基本数据类型直接赋值给包装类：`Integer in = 1`

- 除了Character类之外，其他包装类都有`parseXxx`静态方法将字符串转换为基本类型
- 转换为字符串
  - 值+""，最常用方式
  - `toString()`
  - String类中的静态方法`valueOf()`

# ~~可变参数~~

- 定义方法时使用：`修饰符 返回值类型 方法名(数据类型...变量名)`，通过增强for使用
- 底层是数组，创建不同长度数组
- 一个方法只能有**一个**可变参数，必须写在参数列表**末尾**