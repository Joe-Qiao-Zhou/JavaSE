# 泛型

## 泛型

- **将参数类型也看作一个参数**，未知数据类型，用来接收数据类型，创建集合对象时就会确定泛型的数据类型
- 泛型没有继承概念
- 不使用的利弊
  - 利：Object类型可以存储任意类型
  - 弊：不安全，引发类型转换异常
- 使用的利弊
  - 利：避免类型转换，且运行期异常变为编译期异常
  - 弊：只能存储对应数据
- 定义：数据类型改为E，类后面加上\<E>
- 含有泛型的方法：`修饰符 <泛型> 返回值类型(泛型)`，在调用时确定
  - 含有泛型的接口：`public interface 接口名<泛型>`
  - 使用：定义实现类时指定泛型 or 实现类继续使用泛型

## 泛型通配符

- 不知道使用什么类型接收数据时，使用？表示
- **只能接收**数据不能存储数据，**定义时不能使用**
- 受限泛型：设置上下限
  - ? extends E 只能使用E类型子类/本身
  - ? super E 只能使用E类型父类/本身



# 容器

## Collection

![image-20220224100712505](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220224100712505.png)

- 容器按照存储结构可以分为`Collection`和`Map`，前者存储**元素集合**，后者存储**键值对**；容器**长度可变**；
- `Collection`包括
  - `List`接口：有序，有索引，能重复；包括`Vector`(由于是同步访问所以不常用)、`ArrayList`(数组实现，查询快增删慢)和`LinkedList`(链表实现，查询慢增删快)
  - `Set`接口：无序，无索引，不能重复；包括`HashSet`(哈希表+红黑树)->`LinkedHashSet`(哈希表+链表，有序)、`TreeSet`(二叉树实现，一般用于排序)
  - 常用方法：add()remove()contains()isEmpty()size()toArray()

### Collections工具类

- `Collections.addAll(集合，元素)`：往集合中添加一些元素
- `Collections.shuffle(集合)`
- `sort(集合)`：默认是升序，自定义类型要实现**comprable接口**，重写compreTo()方法，`this.val - o.val`是升序方式
- `sort(集合，Comparator<? super T>)`：按指定规则排序，比较两个对象，但是没有this指针

### Iterator

- 主要用于遍历元素
- `hasNext()`用于判断，`next()`用于取出；指针最初指向-1索引，先取再移
- 作为接口无法使用，但是Collection的实现类有成员方法`iterator()`可以返回一个迭代器对象

### LinkedList

- 双向链表实现；增删快，包含大量操作首尾元素方法：【add/get/remove】【First/Last】、pop()、push()、isEmpty()、clear()

### HashSet

- 无序，不能用fori
- 底层是哈希表，查询快
- 哈希表=数组+链表，数组初始容量为16，存储哈希值，链表/红黑树用于把这些相同哈希元素链接在一起；1.8之后=数组+红黑树，如果超过8个就会转为红黑树，横着是数组，竖着是链表
- 为何不能重复：存储前先计算哈希值，如果存在使用equals()比较内容，相同则不存储；要存储的类对象必须重写`hashCode()`和`equals()`，才能计算哈希值并比较

### LinkedHashList

- 底层是哈希表+链表，多了一条链表，用来记录元素存储顺序保证有序 



## Map

- 常用方法：`V put(K, V)、V get(K)、V remove(K)、boolean containsKey(K)、Set Values()、Set keySet()、Set entrySet()`

  - 若put的K不重复则返回空，否则返回被替换值
  - 后两个方法用来遍历集合
    - **keySet将Map的所有key取出存在一个Set里**
    - entry是键值对，将其取出放在Set集合中，Entry对象有`getKey()`和`getValue()`方法


  ```java
Set<Map.Entry<string, Integer>> set = map.entrySet();
  ```

### HashMap

- 根据键的哈希值存储数据

### Properties

- Hashtable与HashMap相比，不能存储null值null键
- 单线程操作，已被HashMap取代，但其子类Properties还在使用

## 集合添加of()

- 原本对于单列集合使用`add()`，双列集合使用`put()`，JDK9对List、Set、Map定义了静态方法`of()`添加元素
- 前提是集合元素个数确定，即只能**一次性**添加完
- 不适用于接口实现类，只适用于三个抽象接口
- 返回值是个不能改变的集合，不能再使用add、put方法
- Set和Map在使用of()时不能有重复元素





# Stream流

## 概述

- 将集合和数组转换为Stream流，并简化相关操作：只关注做什么，不关注怎么做；使用更好的方式取代for循环

- 流水线思想：得益于Lambda表达式的延迟执行，直到最后方法执行时元素才会被处理

- Stream流是一个集合元素的函数模型，**不是集合也不是数据结构**

- 与Collection操作不同的2个基础特征：

  - PipeLining：中间操作返回流对象本身
  - 内部迭代：不需要Iterator和增强for

## 获取流

- 所有的`Collection`集合都能通过`stream()`方法获取流
- `Stream`接口的静态方法`of()`可以将数组转换为流：`Stream<String> stream = Stream.of("a", "b", "c", "d", "e");`

## 常用方法

- 格式：`容器.stream().延迟方法(Lambda).终结方法(Lambda)`

- 延迟方法：返回Stream接口自身类型，支持链式调用
  - `filter()`：流只能被使用一次，使用完后数据就去往下一个流中
  - `map()`：将流中元素映射到另一个流中
  - `limit()`：只取前几个
  - `skip()`：跳过前几个
  - `concat()`：合并2个流
- 终结方法：
  - `count()`：同Collection`size()`方法，统计元素个数
  - ``forEach()`